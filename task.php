<?php
/**
1. создать класс "девелопер"
1.1. у класса создать публичный метод "голова", который возвращает текст "хочу написать код в %n строк", где "%n" - случайно сгенерированное, положительное, целое число. это число должно быть сохранено в защищенном свойстве этого класса "голова_строк"
1.2. у класса создать публичный метод "руки", который возвращает текст "написал код в %n строк", где "%n" - случайно сгенерированное, положительное, целое число. это число должно быть сохранено в защищенном свойстве этого класса "руки_строк"
1.3. у класса создать публичный метод "итого", который, в случае если число из пункта 1.1. больше 1.2., возвращает текст "сегодня я выполнил план", в противном случае "облажался"
1.4. последовательность вызовов такая:
1.4.1. "голова"
1.4.2. "руки"
1.4.3. "итого"
1.5. если в момент вызова метода "итого" у нас не заданы значения "голова_строк" и "руки_строк", то выбрасывать исключение с сообщением какое именно значение не задано

2. создать класс "верстак", который расширяет класс "девелопер" из пункта 1.
2.1. у класса переопределить метод "руки", который сначала вызывает родительский метод "руки", а затем переназначает переменную "руки_строк" прибавляя к существующему значению 25
2.2. создать объект с классом "верстак"
2.3. вызвать методы у этого класса согласно последовательности пункта 1.4.

названия классов, методов, свойств и объектов не имеют значение но должны быть понятны какое у них предназначение
 */

class grand
{
    public function hands()
    {
        $a = substr(rand(), 8);
        return "Я дед. Написал код в " . $a . " строк <br/>";
    }
}

class developer extends grand
{
    public function head()
    {
        $a = substr(rand(), 8);
        return "Хочу написать код в " . $a . " строк <br/>";
    }
    public function hands()
    {
        $a = substr(rand(), 8);
        return "Я отец. Написал код в " . $a . " строк <br/>";
    }
    public function summary()
    {
        $_a = preg_replace('~[^0-9]+~', '', $this -> head());
        $_b = preg_replace('~[^0-9]+~', '', $this -> hands());

        return $summary = ($_a > $_b) ? "сегодня я выполнил план" : "облажался";
    }
    }

class frontend extends developer
{
    public function hands()
    {
        // здесь ты вызываешь именно родительский метод
        /**
         * фишка в том что если у этого родителя тоже есть родительнь, т.е. "дедушка" для frontend и у него есть метод hands
         * то вызовится метод именно из developer
         * если же у девелопера этого метода нет, а есть у дедушки - то вызовится дедушкин метод
         * вопросы? :)
         * где тут дедушка? у меня ж парент и чилд есть
         * в твоем варианте его нет. я тебе условно его так назвал
         * вот смотри:
         * понятен принцип?
         * ну пока ~
         * почему я вызвать то не могу метод покажи)
         * чей метод?
         * епт…
         * ладно пока других тогда нету вопросов, я еще проверку не сделал на существование, вроде умею, но пока не получилось)
         * потом еще напишу завтра или вечером
         *
         */
        return parent::hands();
    }

}

$dev = new developer();
$front = new frontend();

echo $dev -> head();
echo $dev -> hands();
echo $dev -> summary();
echo '<hr>';

echo $front -> hands();

/**
 * напрямую вызвать метод родителя нельзя, если такой же метод существует у "ребенка".
 * ты правильно сделал что проксирвал вызов родительсвого метода
 */