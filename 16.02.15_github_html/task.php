<?php
/**
1. создать класс "девелопер"
1.1. у класса создать публичный метод "голова", который возвращает текст "хочу написать код в %n строк", где "%n" - случайно сгенерированное, положительное, целое число. это число должно быть сохранено в защищенном свойстве этого класса "голова_строк"
1.2. у класса создать публичный метод "руки", который возвращает текст "написал код в %n строк", где "%n" - случайно сгенерированное, положительное, целое число. это число должно быть сохранено в защищенном свойстве этого класса "руки_строк"
1.3. у класса создать публичный метод "итого", который, в случае если число из пункта 1.1. больше 1.2., возвращает текст "сегодня я выполнил план", в противном случае "облажался"
1.4. последовательность вызовов такая:
1.4.1. "голова"
1.4.2. "руки"
1.4.3. "итого"
1.5. если в момент вызова метода "итого" у нас не заданы значения "голова_строк" и "руки_строк", то выбрасывать исключение с сообщением какое именно значение не задано

2. создать класс "верстак", который расширяет класс "девелопер" из пункта 1.
2.1. у класса переопределить метод "руки", который сначала вызывает родительский метод "руки", а затем переназначает переменную "руки_строк" прибавляя к существующему значению 25
2.2. создать объект с классом "верстак"
2.3. вызвать методы у этого класса согласно последовательности пункта 1.4.

названия классов, методов, свойств и объектов не имеют значение но должны быть понятны какое у них предназначение
 * * фишка в том что если у этого родителя тоже есть родительнь, т.е. "дедушка" для frontend и у него есть метод hands
 * то вызовится метод именно из developer
 * если же у девелопера этого метода нет, а есть у дедушки - то вызовится дедушкин метод
 * вопросы? :)
 * где тут дедушка? у меня ж парент и чилд есть
 * в твоем варианте его нет. я тебе условно его так назвал
 * вот смотри:
 * понятен принцип?
 * ну пока ~
 * почему я вызвать то не могу метод покажи)
 * чей метод?
 * епт…
 * ладно пока других тогда нету вопросов, я еще проверку не сделал на существование, вроде умею, но пока не получилось)
 * потом еще напишу завтра или вечером
 *
 * * напрямую вызвать метод родителя нельзя, если такой же метод существует у "ребенка".
 * ты правильно сделал что проксирвал вызов родительсвого метода
 */

class developer
{
    private $_a;
    private $_b;

    public function head()
    {
        $this->_a = substr(rand(), 8);
        return "Хочу написать код в " . $this->_a . " строк <br/>";
    }
    public function hands()
    {
        $this->_b = substr(rand(), 8);
        return "Написал код в " . $this->_a . " строк <br/>";
    }
    public function summary()
    {
        /*
        $_a = preg_replace('~[^0-9]+~', '', $this -> head());
        $_b = preg_replace('~[^0-9]+~', '', $this -> hands());
        */
        $_a = intval($this->_a)>0?true:false;
        $_b = intval($this->_b)>0?true:false;


        if (!$_a)
        {
            throw new MyEx();
        } elseif (!$_b)
        {
            throw new Exception();
            echo 'ass';
        }

        return $summary = ($_a > $_b) ? "сегодня я выполнил план" : "облажался";
    }
}

class frontend extends developer
{
    public function hands()
    {
        return parent::hands();
    }
    public function head()
    {
        return parent::head();
    }
    public function summary()
    {
        return parent::summary();
    }

}

class MyEx extends Exception{

}

$dev = new developer();
$front = new frontend();

echo $dev -> head();
//  echo $dev -> hands();
try
{
    echo $dev -> summary();
    echo "something";
}
catch (MyEx $e){
    echo "erro";
}
#echo $dev -> summary();
echo '<hr>';

echo $front -> head();
echo $front -> hands();
echo $front -> summary();