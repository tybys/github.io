<!DOCTYPE html>
<html>
<head lang="ru">
    <meta charset="UTF-8">
    <title></title>
    <style>

    </style>
</head>
<body>
<h1>Всё является объектом</h1>

<p>
    Хотя язык Java основан на C++, он является более "чистокровным" объектно-ориентированным языком.

    Как C++, так и Java относятся к семейству смешанных языков, но дял создателей Java эта неоднородность
    была не так важна, если сравнивать с C++. Смешанный язык позволяет использовать несколько стилей
    программирования; причиной смешанной природы C++ стало желание сохранить совместимость с языком C.
    Так как язык C++ является надстройкой языка C, он включает в себя много нежелательных характеристик своего
    предшественника, что приводит к излишнему усложнению некоторых аспектов этого языка.

    Язык программирования Java подразумевает, что вы занимаетесь только объектно-ориентированным программированием.
    А это значит, что прежде, чем начать с ним работать, нужно "переключится" на понятия объектно-ориентированного
    мира (если вы уже этого не сделали).

    Выгода от этого начального усилия - возможность программировать на языке, который по простоте изучения и
    пользования превосходит все остальные языки ООП. В этой главе мы рассмотрим основные Java-программы и узнаем,
    что в Java (почти) всё является объектом.
</p>

<h2>Для работы с объектами используются ссылки</h2>
<p>
    Каждый язык программирования имеет свои манипуляции данными. Иногда программисту приходится быть постоянно в
    курсе, какая именно манимуляция производится в программе. Вы работаете с самим объектом или же с каким-то
    видом его косвенного представления (указатель в C или в C++), требующим особого синтаксиса?

    Все эти различия упрощены в Java. Вы обращаетесь со всем как с объектом, и поэтому повсюду используется единый
    последовательный синтаксис. Хотя вы обращаетесь со всем как с объектом, идентификатор, которым вы манипулируете,
    на самом деле представляет собой ссылку на объект<sup>1</sup>. Представьте себе телевизор (объект) с пультом
    дистанционного управления (ссылка). Во время владения этой ссылкой у вас имеется связь с телевизором,
    но при переключении канала или уменьшении громкости вы распоряжаетесь ссылкой, которая в свою очередь,
    манипулирует объектов. А если вам захочется перейти в другое место комнаты, все еще управляя телевизором, вы
    берёте с собой "ссылку", а не сам телевизор.

    Также пульт может существовать сам по себе, без телевизора. Таким образом, сам факт наличия ссылки еще не
    означает наличия присоединенного к ней объекта. Например, для хранения слова или предложения создается ссылка

    <pre>
        String:
            String s;
    </pre>

    Однако здесь определяется <i>только</i> ссылка, но не объект. Если вы решите послать сообщение s, произойдёт
    ошибка, потому что ссылка s на самом деле ни к чему не присоединена (телевизора нет). Значит, безопаснее всегда
    инициализировать ссылку при её создании:

    <pre>
        String s = "asdf";
    </pre>

    В данном примере используется специальная возможность Java: инициализация строк текстом в кавычках. Обычно вы
    будете использовать более общий способ инициализации объектов.
</p>

<h2>Все объекты дожны создаваться явно</h2>
<p>
    Когда вы определяете ссылку, желательно присоеденить её к новому объекту. В основном это делается при помощи
    ключевого слова new. Фактически оно означает: "Создайте мне новый объект". В предыдущем примере можно написать:

    <pre>
        String s = new String("asdf");
    </pre>

    Это не только значит "предоставьте мне новый объект String", но также казывает, как создать строку посредством
    передачи начального набора символов.

    Конечно, кроме String, в Java имеется множество готовых типов. Важнее то, что вы можете создавать свои
    собственные типы. Вообще говоря, именно создание новых типов станет вашим основным занятием при программировании
    на Java, и именно его мы будет рассматривать в книге.
</p>
<h2>Где хранятся данные</h2>
<p>
    Полезно отчётливо представлять, что происходит во время работы программы - и в частности, как данные
    размещаются в памяти. Существует пять разных мест для хранения данных:

    <ol>
        <li>
            <strong>Регистры.</strong> Это самое быстрое хранилище, потому что данные хранятся прямо внутри
            процессора. Однако количество регистров жестко ограничено, поэтому регистры используются компилятором
            по мере необходимости. У вас нет прямого доступа к регистрам, вы не сможете найти и малейших следов их
            поддержки в языке. (С другой стороны, языки C и C++ позволяют порекомендовать компилятору данные
            в регистрах.)
        </li>
        <li>
            <strong>Стек.</strong> Эта область хранения данных находится в общей оперативной памяти (RAM), но
            процессор предоставляет прямой доступ к ней с использованием <i>указателя стека.</i> Указатель стека
            перемещается вниз для выделения памяти или вверх для её освобождения. Это чрезвычайно быстрый и
            эффективный способ размещения данных, по скорости уступающий только регистрам. Во время обработки
            программы компилятор Java должен знать жизненный цикл данных, размещаемых в стеке. Это ограничение
            уменьшает гибкость ваших программ, поэтому, хотя некоторые данные Java хранятся в стеке (особенно ссылки
            на объекты), сами объекты Java не помещаются в стек.
        </li>
        <li>
            <strong>Куча.</strong> Пул памяти общего назначения (находится также в RAM), в котором размещаются все
            объекты Java. Преимущество кучи состоит в том, что компилятору не обязательно знать, как долго
            просуществуют находящиеся там объекты. Таким образом, работа с кучей даёт значительное преимущество
            в гибкости. Когда вам нужно создать объект, вы пишете код с использованием new, и память выделяется из
            кучи во время выполнения программы. Конечно, за гибкость приходится расплачиваться: выделение памяти
            из кучи занимает больше времени, чем в стеке (даже если вы <i>могли</i> явно создавать объекты в стеке,
            как в C++).
        </li>
        <li>
            <strong>Постоянная память.</strong> Значения констант часто встраиваются прямо в код программы,
            так как они неизменны. Иногда такие данные могут размещать в постоянной памяти (ROM), если речь идёт о
            "встроенных" системах.
        </li>
        <li>
            <strong>Не-оперативная память.</strong> Если данные располагаются вне программы, они могут существовать
            и тогда, когда она ен выполняется. Два основных примера: <i>потоковые объекты</i> (streamed objects),
            в которых объекты представлены в виде потока байтов, обычно используются для посылки на другие машины,
            и <i>долгоживущие</i> (persistent) <i>объекты</i>, которые запоминаются на диске и сохраняют своё
            состояние даже после окончания работы программы. Особенностью этих видов хранения данных является
            возможность перевода объектов в нечто, что может быть сохранено на другом носителе информации,
            а потом восстановлено в виде обычного объекта, хранящегося в оперативной памяти. В Java организована
            поддержка <i>легковесного</i> (lightweight) <i>сохранения состояния,</i> а такие механизмы, как JDBC и
            Hibernate, предоставляют более совершенную поддержку сохранения и выборки информации об объектах из баз
            данных.
        </li>
    </ol>
</p>
<!--50-->

<h2>Особый случай: примитивные типы</h2>
<p>
    Одна из групп типов, часто применяемых при программировании, требует особого обращения. Их можно назвать
    "примитивными" типами (табл. 2.1). Причина для особого обращения состоит в том, что создание объекта с помощью
    new - особенно маленькой простой переменной - недостаточно эффективно, так как new помещает объекты в кучу.
    В таких случаях Java следует примеру языков C и C++. То есть вместо создания переменной с помощью new создается
    "автоматическая" переменная, <i>не являющаяся ссылкой.</i> Переменная напрямую хранит значение и располагается в
    стеке, так что операции с ней гораздо производительнее.

    В Java размеры всех примитивных типов жёстко фиксированы. Они не меняются с переходом на иную машинную
    архитектуру, как это происходит во многих других языках. Незыблемость размера - одна из причин улучшенной
    переносимости Java-программ.

    <h3><strong>Таблица 2.1.</strong> Примитивные типы</h3>
    <table>

            <thead>
                <th>Примитивный тип</th>
                <th>Размер, бит</th>
                <th>Минимум</th>
                <th>Максимум</th>
                <th>Тип упаковки</th>
            </thead>


        <tr>
            <td>boolean (логические значения)</td>
            <td>-</td>
            <td>-</td>
            <td>-</td>
            <td>Boolean</td>
        </tr>
    </table>

    Все числовые значения являются знаковыми, так что не ищите слова unsigned.

    Размер типа boolean явно не определяется; указывается лишь то, что этот тип может принимать значения true и false.

    "Классы-обёртки" позволяют создать в куче не-примитивный объект для представления примитивного типа. Например:

    <pre>
        char c = 'x'.
        Character ch = new Character(c).
    </pre>
</p>
<!--51-->

<p>
    Также можно использовать такой синтаксис:

    <pre>
        Character ch = new Character('x');
    </pre>

    Механизм <i>автоматической упаковки</i> Java SE5 автоматически преобразует примитивный тип в объектную "обёртку":

    <pre>
        Character ch = 'x';
    </pre>

    и обратно

    <pre>
        char c = ch;
    </pre>

    Причины создания подобных конструкий будут объяснены в последующих главах.
</p>

<h2>Числа повышенной точности</h2>
<p>
    В Java существует два класса для проведения арифметических операций повышенной точности:
    <strong>BigInteger </strong>и <strong>BigDecimal</strong>.
    Хотя эти классы примерно подходят под определение "класс-обёрток", ни один из них не имеет аналога среди
    примитивных типов.

    Оба класса содержатметоды, производящие операции, аналогичные тем, что проводятся над примитивными типами. Иначе
    говоря, с классами <strong>BigInteger</strong> и <strong>BigDecimal</strong> можно делать то же, что с
    <strong>int</strong> или <stong>float</stong>, просто для этого используются вызовы методов, а не встроенные
    операции. Также из-за использования увеличенного объема данных операции занимают больше времени. Приходится
    жертвовать скоростью ради точности.

    Класс <strong>BigInteger</strong> поддерживает целые числа произвольной точности. Это значит, что вы можете
    использовать целочисленные значения любой величины без потери данных во время операций.

    Класс <strong>BigDecimal</strong> представляет числа с фиксированной запятой произвольной точности; например,
    они могут применяться для финансовых вычислений.

    За подробностями о конструкторах и методах этих классов обращайтесь в документацию JDK.
</p>

<h2>Массивы в Java</h2>
<p>
    Фактически все языки программирования поддерживают массивы. Использование массивов в C и C++ небезопасно, потому
    что массивы в этих языках представляют собой обычно блоки памяти. Если программа попытается получить доступ к
    массиву за пределами его блока памяти или использовать память без предварительной инициализации (типичные
    ошибки при программировании), последствия могут быть непредсказуемы.

    Одной из основных целей Java является безопасность, поэтому многие проблемы, досаждавшие программистам на C и C++,
    не существуют в Java. Массив в Java гарантированно инициализируется, к нему невозможен доступ за пределами его
    границ. Проверка границ массива обходится относительно дорого, как и проверка индекса во время выполнения, но
    предполагается, что повышение безопасности и подъём производительности стоят того (к тому же Java иногда
    может оптимизировать эти операции).
</p>
<!--52-->

<p>
    При объявлении массива объектов на самом деле создается массив ссылок, и каждая из этих ссылок автоматически
    инициализируется специальным значением, представленным ключевым словом <strong>null.</strong> Оно означает,
    что ссылка на самом деле не указывается на объект. Вам необходимо присоединять объект к каждой ссылке перед
    тем, как её использовать, или при попытке обращения по ссылке null во время исполнения программы произойдёт ошибка.
    Таким образом, типичные ошибки при работа с массивами в Java предотвращаются заблаговременно.

    Также можно создавать массивы простейших типов. И снова компилятор гарантирует инициализацю - выделенная для
    нового массива память заполняется нулями.

    Массивы будут подробнее описаны в последующих главах.
</p>

<h2>Объекты никогда не приходится удалять</h2>
<p>
    В большинстве языков программирования концепция жизненного цикла переменной требует относительно заметных
    усилий со стороны программиста. Сколько "живёт" переменная? Если её необходимо удалить, когда это следует делать?
    Путаница со сроками существования переменных может привести ко многим ошибкам, и этот раздел показывает, насколько
    Java упрощает решение затронутого вопроса, выполняя всю работу по удалению за вас.
</p>

<h2>Ограничение области действия</h2>
<p>
    В большинстве процедурных языков существует понятие <i>области действия</i> (scope). Область действия
    определяет как видимость, так и срок жизни имён, определенных внутри неё. В C, C++ и Java область действия
    устанавливается положением фигурных скобок {}. Например:

    <pre>
    {
        int x = 12;
        // доступно только x
        {
            int q = 96;
            // доступны как x, так и q
        }
        // доступно только x
        // q находится "за пределами видимости"
    }
    </pre>

    Переменная, определенная внутри области действия, доступна только в пределах этой области.

    Весь текст после символов // и до конца строки является комментарием.

    Отступы упрощают чтение программы на Java. Так как Java относится к языкам со свободным форматом,
    дополнительные пробелы, табуляция и переводы строк не влияют на результирующую программу.

    Учтите, что следующая конструкция <i>не разрешена</i>, хотя в C и C++ она возможна:
</p>
<!--53-->

<p>
    <pre>
        {
            int x = 12;
            {
                int x = 96; // неверно
            }
        }
    </pre>

    Компилятор объявит, что переменная x уже была определена. Таким образом, возможность языков C и C++ "прятать" переменные
    во внешней области действия не поддерживается. Создатели Java посчитали, что она приводит к излишнему усложнению программ.
</p>

<h2>Область действия объектов</h2>
<p>
    Объекты Java имеют другое время жизни в сравнеи с примитивами. Объект, созданный оператором Java <strong>new</strong>,
    будет доступен вплоть до конца области действия. Если вы напишите:

    <pre>
        {
            String s = new String("строка");
        } // конец области действия
    </pre>

    то ссылка s исчезнет в конце области действия. Однако объект String, на который указывала s, всё ещё будет занимать
    память. В показанном фрагменте кода невозможно получить доступ к объекту, потому что единственная ссылка вышла
    за пределы видимости. В следующих главах вы узнаете, как передаются ссылки на объекты и как их можно копировать во
    время работы программы.

    Благодаря тому, что объекты, созданные <strong>new</strong>, существуют ровно столько, сколько вам нужно, в Java
    исчезает целый пласт проблем, присущих C++. В C++ приходится не только следить за тем, чтобы объекты продолжали
    существовать на протяжении своего жизненного цикла, но и удалять объекты после завершения работы с ними.

    Возникает интересный вопрос. Если в Java объекты остаются в памяти, что же мешает им постепенно занять всю память
    и остановить выполнение программы? Именно это произошло бы в данном случае в C++. Однако в Java существует
    <i>сборщик мусора</i> (garbage collector), который наблюдает за объектами, созданными оператором <strong>new</strong>,
    и определяет, на какие из них больше нет ссылок. Тогда он освобождает память от этих объектов, которая становится
    доступной для дальнейшего использования. Таким образом, вам никогда не придётся "очищать" память вручную. Вы просто
    создаёте объекты, и как только надобность в них отпадёт, эти объекты исчезают сами по себе. При таком подходе
    исчезает целый класс проблем программирования: так называется "утечки памяти", когда программист забывает
    освобождать занятую память.
</p>

<h2>Создание новы типов данных</h2>
<p>
    Если всё является объектом, что определяет строение и поведение класса объектов? Другими словами, как устанавливается
    <i>тип</i> объекта? Наверное, для этой цели можно было бы использовать ключевое слово <strong>type</strong> ("тип");
    это было бы вполне разумно. Впрочем, с давних времён повелось, что большинство объектно-ориентированных языков
    использовали ключевое слово <strong>class</strong> в смысле "Я собираюсь описать новый тип объектов". За ключевым
    словом <strong>class</strong> следует имя нового типа. Например:

    <pre>
        class ATypeName { /* Тело класса */ }
    </pre>

    Эта конструкция вводит новый тип, и поэтому вы можете теперь создавать объект этого типа ключевым словом new:

    <pre>
        ATypeName a = new ATypeName();
    </pre>

    Впрочем, объекту нельзя "приказать" что-то сделать ( то есть послать ему необходимые сообщения) до тех пор,
    пока для него не будут определены методы.
</p>

<h2>Поля и методы</h2>
<p>
    При определении класса (строго говоря, вся ваша работа на Java сводится к определению классов, созданию объектов
    этих классов и посылке сообщений этим объектам) в него можно включить две разновидности элементов: <i>поля</i>
    (fields)(иногда называемые переменными класса) и <i>методы</i> (methods) (еще называемые функциями класса). Поле
    представляет собой объект любого типа, с которым можно работать по ссылке, или объект примитивного типа. Если
    используется ссылка, её необходимо инициализировать, чтобы связать с реальным объектом (ключевым словом new, как было
    показано ранее).

    Каждый объект использует собственный блок памяти для своих полей данных; совместное использование обычный полей
    разными объектами класса невозможно. Пример класса с полями:

    <pre>
        class DataOnly {
            int i;
            double d;
            boolean b;
        }
    </pre>

    Такой класс ничего не <i>делает</i>, кроме хранения данных, но вы можете создать объект этого класса:

    <pre>
        DataOnly data = new DataOnly();
    </pre>

    Полям класса можно присваивать значения, но для начала необходимо узнать, как обращаться к членам объекта. Для
    этого сначала указывается имя ссылки на объект, затем следует точка, а далее - имя члена, принадлежащего объекту:

    <pre>
        ссылка.член
    </pre>

    Например:

    <pre>
        data i = 47;
        data.d = 1.1;
        data.b = false;
    </pre>

    Также ваш объект может содержать другие объекты, данные которых вы хотели бы изменить. Для этого просто продолжите
    "цепочку из точек". Например:

    <pre>
        myPlane.leftTank.capacity = 100;
    </pre>

    Класс DataOnly не способен ни на что, кроме хранения данных, так как в нём отсутствуют методы. Чтобы понять, как
    они работают, необходимо разобраться, что такое <i>аргументы</i> и <i>возвращаемые значения</i>. Вскоре мы вернёмся
    к этой теме.
</p>

<h2>Значения по умолчанию для полей примитивных типов</h2>
<p>
    Если поле данных относится к примитивному типу, ему гарантировано присваивается значение по умолчанию, даже если
    оно не было инициализировано явно (табл. 2.2).

    <h3><strong>Таблица 2.2.</strong> Значения по умолчанию для полей примитивных типов</h3>
    <table>
        <thead>
            <td><strong>Примитивный тип</strong></td>
            <td><strong>Значение по умолчанию</strong></td>
        </thead>
        <tr>
            <td>boolean</td>
            <td>false</td>
        </tr>
        <tr>
            <td>char</td>
            <td>`\u0000` (null)</td>
        </tr>
        <tr>
            <td>byte</td>
            <td>(byte)0</td>
        </tr>
        <tr>
            <td>short</td>
            <td>(short)0</td>
        </tr>
        <tr>
            <td>int</td>
            <td>0</td>
        </tr>
        <tr>
            <td>long</td>
            <td>0L</td>
        </tr>
        <tr>
            <td>float</td>
            <td>0.0f</td>
        </tr>
        <tr>
            <td>double</td>
            <td>0.0d</td>
        </tr>
    </table>

    Значения по умолчанию гарантируются Java только в том случае, если переменная используется <i>как член класса.</i>
    Тем самым обеспечивается обязательная инициализация элементарных типов(что не делается в C++), которая уменьшает
    вероятность ошибок. Однако значение по умолчанию может быть неверным или даже недопустимым для вашей программы.
    Переменные всегда лучше инициализировать явно.

    Такая гарантия не относится к <i>локальным переменным</i>, которые не являются полями класса. Допустим, в определении
    метода встречается объявление переменной

    <pre>
        int x;
    </pre>

    Переменной x будет присвоено случайное значение (как в C и C++); она не будет автоматически инициализирована нулём.
    Если же вы забудете это сделать, в Java существует очевидное преимущество в сравнении с C++: компилятор выдаёт
    ошибку, в которой указано, что переменная не была инициализирована. (Многие компиляторы C++ предупреждают о таких
    переменных, но в Java это считается ошибкой.)
</p>

<h2>Методы, аргументы и возвращаемые значения</h2>
<p>
    Во многих языках (таких как C и C++) для обозначения именованной подпрограммы употребляется термин <i>функция</i>.
    В Java чаще предпочитают термин <i>метод</i>, как бы подразумевающий "способ что-то сделать". Если вам хочется,
    вы можете продолжать пользоваться термином "функция". Разница только в написании, но в дальнейшем в книге будет
    употребляться преимущественно термин "метод".

    Методы в Java определяют сообщения, принимаемые объектом. Осовные части метода - имя, аргументы, возвращаемый тип
    и тело. Вот примерная форма:

    <pre>
        возвращаемыйТип ИмяМетода( /* список аргументов */ ) {

        }
    </pre>

    Возвращаемый тип - это тип объекта, "выдаваемого" методом после его вызова. Список агрументов определяет типы и
    имена для информации, которую вы хотите передать в метод. Имя метода и его список аргументов (объединяемые термином
    <i>сигнатура</i>) обеспечивают однозначную идентификацию метода.

    Методы в Java создаются только как части класса. Метод может вызываться только для объекта
    <sup>
        1
        <span hidden>
            Статические методы, о которых вы узнаете немного позже, вызываются для <i>класса</i>, а не для объекта.
        </span>
    </sup>,
    и этот объект должен обладать возможностью произвести такой вызов. Если вы попытаетесь вызвать для объекта
    несуществующий метод, то получите ошибку копиляции. Вызов метода осуществляется следующим образом: сначала
    записывается имя объекта, за ним точка, за ней следуют имя метода и его список аргументов:

    <pre>
        имяОбъекта.имяМетода(арг1, арг2, арг3)
    </pre>

    Например, представьте, что у вас есть метод f(), вызываемый без аргументов, который возвращает значение типа int.
    Если у вас имеется в наличии объект a, для которого может быть вызван метод f(), в вашей власти использовать
    следующую конструкцию:

    <pre>
        int x = a.f();
    </pre>

    Тип возвращамемого значения должен быть совместим с типом x.

    Такое действие вызова метода часто называется <i>посылкой сообщения объекту</i>.

    В примере выше сообщением является вызов f(), а объектом - a. Объектно-ориентированное программирование нередко
    характеризуется обобщающей фомулой "помылка сообщений объектам".
</p>

<h2>Список аргументов</h2>
<p>
    Список аргументов определяет, какая информация передаётся методу. Как легко догадаться, эта информация - как и все
    в Java - воплощается в форме объектов, поэтому в списке должны быть указаны как типы передаваемых объектов, так и их
    имена. Как и в любой другой ситуации в Java, где мы вроде бы работает с объектами, на самом деле используются
    ссылки.
    <sup>
        2
        <span>
            За исключением уже упомянутых "специальных" типов данных: boolean, byte, short, char, int, float, long,
            double. Впрочем, в основном вы будете передавать объекты, а значит, ссылки на них.
        </span>
    </sup>


    Впрочем, тип ссылки должен соответствовать типу передаваемых данных. Если предполагается, что аргумент является
    строкой (то есть объектом String), вы должны передать именно строку, или ожидайте сообщения об ошибке.

    Рассмотрим метод, получающий в качестве аргумента строку (String). Следующее определение должно размещаться внутри
    определения класса, для которого создаётся метод:

    <pre>
        int storage(String s) {
            return s.length() * 2;
        }
    </pre>

    Метод указывает, сколько байтов потребуется для хранения данных определённой строки. (Строки состоят из символов
    char, размер которых - 16 бит, или 2 байта; это сделано для поддержки набора символов Unicode.) Аргумент имеет
    тип String и называется s. Получив объект s, метод может работать с ним точно так же, как и с любым бругим объектом
    (то есть посылать ему сообщения). В данном случае вызывается метод length(), один из методов класса String;
    он возвращает количество символов в строке.

    Также обратите внимание на ключевое слово return, выполняющее два действия. Во-первых, оно означает: "выйти
    из метода, всё сделано". Во-вторых, если метод возвращает значение, это значение указывается сразу же за
    командой return. В нашем случае возвращаемое значение - это результат вычисления

    <pre>
        s.length() * 2.
    </pre>

    Метод может возвращать любой тип, но, если вы не хотите пользоваться этой возможностью, следует указать, что метод
    возвращает void. Ниже приведено несколько примеров:

    <pre>
        boolean flag() { return true; }
        float naturalLogBase() { return 2.718; }
        void nothing() { return; }
        void nothing2() {}
    </pre>

    Когда выходным типом является void, ключевое слово return нужно лишь для завершения метода, поэтому при достижении
    конца метода его присутствие необязательно. Вы можете покинуть метод в любой момент, но если при этом указывается
    возвращаемый тип, отличный от void, то компилятор заставит вас (сообщениями об ошибках) вернуть подходящий тип
    независимо от того, в каком месте было прервано выполнение.

    К этому моменту может сложиться впечатление, что программа - это просто "свалка" объектов со своими методами,
    которые принимают другие объекты в качестве аргументов и посылают им сообщения. По большому счёту так оно и есть,
    но в следующей главе вы узнаете, как производить кропотливую низкоуровневую работу с принятием решений внутри
    метода. В этой главе достаточно рассмторения на уровне посылки сообщений.
</p>

<h2>Создание программы на Java</h2>
<p>
    Есть ещё несколько вопросов, которые необходимо поднять перед созданием первой программы на Java.
</p>

<h2>Видимость имён</h2>
<p>
    Проблема управления именами присуща любому языку программирования.

    Если имя используется в одном из модулей программы и оно случайно совпало с именем в другом модуле у другого
    программиста, то как отличить одно имя от другого и предотвратить их конфликт? В C это определённо является
    проблемой, потому что программа с трудом поддаётся контролю в условиях "моря" имён. Классы C++ (на которых основаны
    классы Java) скрывают функции внутри классов, поэтому их имена не пересекаются с именами функций других классов.
    Однако в C++ дозволяется использование глобальных данных и глобальных функций, соответственно, конфликты полностью
    не исключены. Для решения означенной проблемы в С++ введены <i>пространства имён</i> (namespaces), которые
    используют дополнительные ключевые слова.

    В языке Java для решения этой проблемы было использовано свежее решение. Для создания уникальных имён библиотек
    разработчики Java предлагают использовать доменное имя, записанное "наоборот", так как эти имена всегда уникальны.

    Моё доменное имя -
    <code>
        MindView.net, и утилиты моей программной библиотеки могли бы называться <code>net.mindview.utility.foibles.</code>
        За перевёрнутым доменным именем следует перечень каталогов, разделённых точками.
    </code>

    В версиях Java 1.0 и 1.1 доменные суффиксы com, edu, org, net по умолчанию записывались заглавными буквами, таким
    образом, имя библиотеки выглядело так:

    <code>
        NET.mindview.utility.foibles.
    </code>

    В процессе разработки Java 2 было обнаружено, что принятый подход создаёт проблемы, и с тех пор имя записывается
    строчными буквами.

    Такой механизм значит, все ваши файлы автоматически располагаются в своих собственных пространствах имён, и каждый
    класс в файле должен иметь уникальный идентификатор. Язык сам предотвращает конфликты имён.
</p>

<h2>Использование внешних компонентов</h2>
<p>
    Когда вам понадобится использовать уже определённый класс в вашей программе, компилятор должен знать, как этот
    класс обнаружить. Конечно, класс может уже находиться в том же самом исходном файле, откуда он вызывается.
    В таком случае вы просто его используете - даже если определение класса следует где-то дальше в файле
    (В Java не существует проблемы "опережающих ссылок".)

    Но что, если класс находится в каком-то внешнем файле? Казалось бы, компилятор должен запросто найти его, но здесь
    существует проблема. Представьте, что вам необходим класс с неким именем, для которого имеется более одного
    определения (вероятно, отличающихся друг от друга). Или, что ещё хуже, представьте, что вы пишите программу и при
    её создании в библиотеку добавляется новый класс, конфликтующий с именем уже существующего класса.

    Для решения проблемы вам необходимо устранить все возможные неоднозначности. Задача решается при помощи ключевого
    слова import, которое говорит компилятору Java, какие точно классы нужны. Слово import приказывает компилятору
    загрузить <i>пакет</i> (package), представляющий собой библиотеку классов. (В других языках библиотека может
    состоять как из классов, так и из функций и данных, но в Java весь код принадлежит классам.)

    Большую часть времени вы будете работать с компонентами из стандартных библиотек Java, поставляющихся с компилятором.
    Для них не нужны длинные обращённые доменные имена; вы просто записываете

    <pre>
        import java.util ArrayList;
    </pre>

    чтобы сказать компилятору, что вы хотите использовать класс ArrayList. Впрочем, пакет util содержит множество
    классов, и вам могут понадобиться несколько из них. Чтобы избежать последовательного перечисления классов,
    используйте подстановочный символ *;

    <pre>
        import java util.*.
    </pre>

    Как правило, импортируется целый набор классов именно таким образом, а не выписывается каждый класс по отдельности.
</p>

<h2>Ключевое слово static</h2>
<p>
    Обычно при создании класса вы описываете, как объекты этого класса ведут себя и как они выглядят. Объект появляется
    только после того, как он будет создан ключевым словом new, и только начиная с этого момента для него выделяется
    память и появляется возможность вызова методов.

    Но есть две ситуации, в которых такой подход недостаточен. Первая - это когда некоторые данные должны храниться
    "в единственном числе" независимо от того, сколько было создано объектов класса. Вторая - когда вам потребуется метод,
    не привязанный ни к какому конкретному объекту класса (то есть метод, который можно вызвать даже при полном отсутствии
    объектов класса). Такой эффект достигается использованием ключевого слова static, делающего элемент класса
    <i>статическим</i>. Когда вы объявляете что-либо как static, это означает, что данные или метод не привязаны
    к определённому экземпляру этого класса. Поэтому, даже если вы никогда не создавали объектов класса, вы можете
    вызвать статический метод или получить доступ к статическим данным. С обычным объектом вам необходимо сначала
    создать его и использовать для вызова метода или доступа информации, так как нестатические данные и методы должны
    точно знать объект с которым работают.

    Некоторые объектно-ориентированные языки используют термины <i>данные уровня класса</i> и <i>методы уровня класса</i>,
    подразумевая, что данные и методы существуют только на уровне класса в целом, а не для отдельных объектов этого
    класса. Иногда эти термины встречаются в литературе по Java.

    Чтобы сделать данные или метод статическими, просто поместите ключевое слово static перед их определением.
    Например, следующий код создаёт статическое поле класса и инициализирует его:

    <pre>
        class StaticTest {
            static int = 47;
        }
    </pre>

    Теперь, даже при создании двух объектов <code>StaticTest</code>, для элемента <code>StaticTest.i</code> выделяется
    единственный блок памяти. Оба объекта совместно используют одно значение i. Пример:

    <pre>
        StaticTest st1 = new StaticTest();
        StaticTest st2 = new StaticTest();
    </pre>

    В данном примере как <code>st1.i</code>, так и <code>st2.i</code> имеют одинаковые значения, равные 47, потому что
    расположены они в одном блоке памяти.

    Существует два способа обратиться к статической переменной. Как было видно выше, вы можете указать её с помощью
    объекта, например st2.i. Также можно обратиться к ней прямо по имени класса (для нестатических членов класса такая
    возможность отсуствует):

    <pre>
        StaticTest i++.
    </pre>

    Оператор ++ увеличивает значение на единицу (инкремент). После выполнения этой команды значения st1.i и st2.i будут
    равны 48.

    Синтаксис с именем класса является предпочтительным, потому что он не только подчёркивает, что переменная описана как
    static, но и в некоторых случаях предоставляет компилятору больше возможностей для оптимизации.

    Та же логика верна и для статических методов. Вы можете обратиться к такому методу или через объект, как это делается
    для всех методов, или в специальном синтаксисе <code>имяКласса.метод().</code> Статические методы определяются по
    аналогии со статическими данными:

    <pre>
        class Incrementable {
            static void increment() { StaticTest i++; }
        }
    </pre>

    Нетрудно заметить, что метод increment() класса Incrementable увеличивает значение статического поля i. Метод
    можно вызвать стандартно, через объект:

    <pre>
        Incrementable sf = new Incrementable();
        sf increment();
    </pre>

    Или, поскольку increment() является статическим, можно вызвать его с прямым указанием класса:

    <pre>
        Incrementable.increment();
    </pre>

    Применительно к полям ключевое слово static радикально меняет способ определения данных: статические данные
    существуют на уровне класса, в то время как нестатические данные существуют на уровне объектов, но в отношении
    изменения не столь принципиальны. Одним из важных применений static является определение методов, которые могут
    вызываться без объектов. В частности, это абсолютно необходимо для метода <code>main()</code>, который представляет собой точку
    входа в приложение.
</p>

<h2>Наша первая программа на Java</h2>
<p>
    Наконец, долгожданная программа. Она запускается, выводит на экран строку, а затем текущую дату, используя стандартный
    класс Date из стандартной библиотеки Java:

    <pre>
	// HelloDate.java
	import java util.*;

	public class HelloDate {
		public static void main(String[] args) {
			System.out.println("Привет. сегодня: ");
			System.out.println(new Date());
		}
	}
    </pre>

	В начале каждого файла с программой должны находиться директивы import, в которых перечисляются все дополнительные
	классы, необходимые вашей программе. Обратите внимание на слово "дополнительные" - существует целая библиотека
	классов, присоединяющаяся автоматически к каждому файлу <code>Java: java.lang.</code> Запустите ваш браузер
	и просмотрите документацию фирмы Sun. Учтите, что документация не входит в комплект JDK; её необходимо загрузить
	отдельно. Взглянув на список пакетов, вы найдёте в нём различные библиотеки классов, составляющих эту библиотеку.
	Так как пакет <code>java.lang.</code> автоматически включается в каждую программу на Java, эти классы всегда
	доступны для использования. Класса Date в нём нет, а это значит, что для его использования придётся импортировать
	другую библиотеку. Если вы не знаете, в какой библиотеке находится нужный класс, или если вам понадобится увидеть
	все классы, выберите <strong>Tree</strong> (дерево классов) в документации. В нём можно обнаружить любой из
	доступных классов Java. Функция поиска текста в браузере поможет найти класс <strong>Date.</strong> Результат поиска
	показывает, что класс называется <code>java.util.Date</code>, то есть находится в библиотеке util, и для получения
	доступа к классу Date необходимо будет использовать директиву import для загрузки пакета <code>java.util.*.</code>

	Если вы вернётесь к началу, выберете пакет <code>java.lang</code>, а затем класс System, то увидите, что он имеет
	несколько полей. При выборе поля out обнаруживается, что оно представляет собой статический объект PrintStream. Так
	как поле описано с ключевым словом static, вам не понадобится создавать объекты. Действия, которые можно выполнять
	с объектом out, определяются его типом: PrintStream. Для удобства в описание этого типа включена гиперссылка, и,
	если щёлкнуть на ней, вы обнаружите список всех доступных методов. Этих методов довольно много, и они будут позже
	рассмотрены в книге. Сейчас нас интересует только метод println(), вызов которого фактически означает: "вывести то,
	что передано методу, на консоль и перейти на новую строку". Таким образом, в любую программу на Java можно включить
	вызов вида <code>System.out.println("что-то"), чтобы вывести сообщение на консоль.</code>

	Имя класса совпадает с именем файла. Когда вы создаёте отдельную программу, подобную этой, один из классов,
	описанных в файле, должен иметь совпадающее с ним название. (Если это условие нарушено, компилятор сообщит об ошибке.)
	Одноимённый класс должен содержать метод с именем main() со следующей сигнатурой и возвращаемым типом:

	<pre>
		public static void main(String[] args) {
	</pre>

	Ключевое слово public обозначает, что метод доступен для внешнего мира (об этом подробно рассказывает глава 5).
	Аргументом метода main() является массив строк. В данной программе массив args не используется, но компилятор Java
	настаивает на его присутствии, так как массив содержит параметры, переданные программе в командной строке.

	Строка, в которой распечатывается число, довольно интересна:

	<pre>
		System.out.println(new Date());
	</pre>

	Аргумент представляет собой объект Date, который создаётся лишь  затем, чтобы передать своё значение (автоматически
	преобразуемое в String) методу println(). Как только команда будет выполнена, объект Date становится ненужным,
	сборщик мусора заметит это, и в конце концов сам удалит его. Нам не нужно беспокоиться о его удалении самим.
</p>

<h2>Комментарии и встроенная документация</h2>
<p>
	В Java приняты два вида комментариев. Первый - традиционные комментарии в стиле C, также унаследованные языком C++.
	Такие комментарии начинаются с комбинации /* и распространяются иногда на множество строк, после чего заканчиваются
	символами */. Заметьте, что многие программисты начинают каждую новую строку таких комментариев символом *,
	соответственно, часто можно увидеть следующее:

	<pre>
	/* Это комментарий.
	* распространяющийся на
	* несколько строк
	*/
	</pre>

	Впрочем, все символы между /* и */ игнорируются, и с таким же успехом можно использовать запись

	<pre>
		/* Это комментарий, распространяющийся
		на несколько строк */
	</pre>

	Второй вид комментария пришёл из языка C++. Однострочный комментарий начинается с комбинации // и продолжается до
	конца строки. Такой стиль удобен и прост, поэтому широко используется на практике. Вам не приходится искать на
	клавиатуре сначала символ /, а затем * (вместо этого вы дважды нажимаете одну и ту же клавишу), и не нужно закрывать
	комментарий. Поэтому часто можно увидеть такие примеры:

	<pre>
		// это комментарий в одну строку
	</pre>
</p>

<h2>Документация в комментариях</h2>
<p>
	Пожалуй, основные проблемы с документированием кода связаны с его сопровождением. Если код и его документация
	существуют раздельно, корректировать описание программы при каждом её изменении становится задачей не из лёгких.
	Решение выглядит очень просто: совместить код и документацию. Проще всего объединить их в одном файле. Но для
	полноты картины понадобится специальный синтаксис комментариев, чтобы помечать документацию, и инструмент, который
	извлекал бы эти комментарии и оформлял их в подходящем виде. Именно это было сделано в Java.

	Инструмент для извлечения комментариев называется javadoc, он является частью пакета JDK. Некоторые возможности
	компилятора Java используются в нём для поиска пометок в комментариях, включенных в ваши программы. Он не только
	извлекает помеченную информацию, но также узнает имя класса или метода, к которому относится данный фрагмент
	документации. Таким образом, с минимум затраченных усилий можно создать вполне приличную сопроводительную
	документацию для вашей программы.

	Результатом работы программы javadoc является HTML-файл, который можно просмотреть в браузере. Таким образом,
	утилита javadoc позволяет создавать и поддерживать единый файл с исходным текстом и автоматически строить полезную
	документацию. В результате получается простой и практичный стандарт по созданию документации для всех библиотек
	Java.

	Вдобавок, вы можете дополнить javadoc своими собственными расширениями, называемыми <i>доклетами</i> (docklets),
	в которых можно проводить специальные операции над обрабатываемыми данными (например, выводить их в другом формате).

	Далее следует лишь краткое введение и обзор основных возможностей java-doc. Более подробное описание можно найти в
	документации JDK. Распаковав документацию, загляните в папку tooldocs (или перейдите по ссылке tooldocs).
</p>

<h2>Синтаксис</h2>
<p>
	Все команды javadoc находятся только внутри комментариев /**. Комментарии, как обычно, завершаются последовательно */.
	Комментарии, как обычно, завершаются последовательностью */. Существует два основных способа работы с javadoc:
	встраивание HTML-текста или использование разметки документации (тегов). <i>Самостоятельные теги документации</i> -
	это команды, которые начинаются символом @ и размещаются с новой строки комментария. (Начальный символ * игнорируется.)
	<i>Встроенные теги документации</i> могут располагаться в любом месте комментария javadoc, также начинается со
	знака @, но должны заключаться в фигурные скобки.

	Существует три вида документации в комментариях для разных элементов кода: класса, переменной и метода. Комментарий
	к классу записывается прямо перед его определением; комментарий к переменной размещается непосредственно перед её
	определением, а комментарий к методу тоже записывается прямо перед его определением. Простой пример:

	<pre>
	// object/Documentation1.java
	/** Комментарий к классу */
	public class Dcumentation1 {
		/** Комментарий к переменной */
		public int i;
		/** Комментарий к методу */
		public void f() {}
	} /// .~
	</pre>

	Заметьте, что javadoc обрабатывает документацию в комментариях только для членов класса с уровнем доступа
	public и protected. Комментарии для членов private и членов с доступом в пределах пакета игнорируются, и
	документация по ним не строится. Впрочем, флаг - private включает обработку и этих членов). Это вполне логично,
	поскольку только public - и protected - члены доступны вне файла, и именно они интересуют программиста - клиента.

	Результатом работы программы является HTML - файл в том же формате, что и остальная документация для Java, так что
	пользователям будет привычно и удобно просматривать и вашу документацию. Попробуй набрать текст предыдущего примера,
	"пропустите" его через javadoc и просмотрите полученный HTML - файл, чтобы увидеть результат.
</p>

<h2>Встроенный HTML</h2>
<p>
	Javadoc вставляет команды HTML в итоговый документ. Это позволяет полностью использовать все возможности HTML;
	впрочем, данная возможность прежде всего ориентирована на форматирование кода:

	<pre>
	//: object/Documentation2.java
	/**
	* &gt;pre>
	* System out println(new Date());
	* </pre>
	*/
	///:~
	</pre>

	Вы можете использовать HTML точно так же, как в обычных страницах, чтобы привести описание к нужному формату:

	<pre>
		//: object/Dcumentation3.java
		/**
		* Можно <em>даже</em> вставить список:
		* <ol>
		* <li> Пункт первый </li>
		* <li> Пункт второй </li>
		* <li> Пункт третий </li>
		* </ol>
		*/
		///:~
	</pre>

	Javadoc игнорирует звёздочки в начале строк, а также начальные пробелы. Текст переформатируется таким образом,
	чтобы он отвечал виду стандартной документации. Не используйте заголовки вида <code>&lt;h1&gt;</code> или <code>&lt;h2&gt;</code>
	во встроенном HTML, потому что javadoc вставляет свои собственные заголовки и ваши могут с ними "пересечься".

	Встроенный HTML-код поддерживается всеми типами документации в комментариях - для классов, переменных или методов.
</p>

<h2>Примеры тегов</h2>
<p>
	Далее описаны некоторые их тегов javadoc, используемых при документировании программы. Прежде чем применять javadoc
	для каких-либо серьёзных целей, просмотрите руководство по нему в документации пакета JDK, чтобы получить полную
	информацию о его использовании.

	<h4>@see: ссылка на другие классы</h4>
	Тег позволяет ссылаться на документацию к другим классам. Там, где были записаны теги @see, Javadoc создаёт HTML-
	ссылки на другие документы. Основные формы использования тега:

	<pre>
		@see имя класса
		@see полное-имя-класса
		@see полное-имя-класса#имя-метода
	</pre>

	Каждая из этих форм включает в генерируемую документацию замечание See Also ("см. также") со ссылкой на указанные
	классы. Javadoc не проверяет передаваемые ему гиперссылки.

	<h4>{@link пакет.класс#член_класса метка}</h4>
	Тег очень похож на @see, не считая того, что он может использоваться как встроенный, а вместо стандартного текста
	See Also в ссылке размещается текст, указанный в поле метка.

	<h4>{@docRoot}</h4>
	Позволяет получить относительный пусть к корневой папке, в которой находится документация. Полезен при явном задании
	ссылок на страницы из дерева документации.

	<h4>{@inheritDoc}</h4>
	Наследует документацию базового класса, ближайшего к документируемому классу, в текущий файл с документацией.

	<h4>@version</h4>
	Имеет следующую форму:
	<pre>
		@version информация-о-версии
	</pre>

	Поле информации о версии содержит ту информацию, которую вы сочли нужным включить. Когда в командной строке javadoc
	указывается опция - version, в созданной документации специально отводится место, заполняемое информацией о версиях.

	<h4>@author</h4>
	Записывается в виде
	<pre>
		@author информация-об-авторе
	</pre>
Предполагается, что поле <code>информация-об-авторе</code> представляет собой имя автора, хотя в него также
можно включить адрес электронной почты и любую другую информацию. Когда в командной строке javadoc указывается
опция - author, в созданной документации сохраняется информация об авторе.

Для создания списка авторов можно записать сразу несколько таких тегов, но они должны размещаться последовательно.
Вся информация об авторах объединяется в один раздел сгенерированном коде HTML.

<h4>@since</h4>
Тег позволяет задать версию кода, с которой началось использование некоторой возможности. В частности, он присуствует
в HTML-документации по Java, где служит для указания версии JDK.

<h4>@param</h4>
Полезен при документировании методов. Форма использования:

    <pre>
        @param имя-параметра описание
    </pre>

где <code>имя-параметра</code> - это идентификатор в списке параметров метода, а описание - текст описания,
который можно продолжить на несколько строк. Описание считается завершенным, когда встретится новый тег. Можно
записывать любое количество тегов @param, по одному для каждого параметра метода.

<h4>@return</h4>
Форма использования:

    <pre>
        @return описание
    </pre>

где описание объясняет, что именно возвращает метод. Описание может состоять из нескольких строк.

<h4>@throws</h4>
Исключения будут рассматриваться в главе 9. В двух словах это объекты, которые можно "возбудить" (throw) в методе,
если его выполнение потерпит неудачу. Хотя при вызове метода создаётся всегда один объект исключения, определенный
метод вырабатывать произвольное количество исключений, и все они требуют описания. Соотвественно, форма тега такова:

    <pre>
        @throws полное-имя-класса описание
    </pre>

где <code>полное-имя-класса</code> уникальное имя класса исключения, который где-то определён, а описание
(расположенное на произвольном количестве строк) объясняет, почему данный метод способен создавать это
исключение при своём вызове.

<h4>@deprecated</h4>
Тег используется для пометки устаревших возможностей, замещённых новыми и улучшенными. Он сообщает о том, что
определённые средства программы не следует использовать, так как в будущем они, скорее всего, будут убраны.
В Java SE5 тег @depracated был заменен <i>директивой</i> @Deprecated (см. далее).
</p>

<h2>Пример документации</h2>
<p>
    Вернёмся к нашей первой программе на Java, но на этот раз добавит в неё комментарии со встроенной документацией:

    <pre>
    //: object/HelloDate.java
    import java util.*;

    /** Первая программа-пример книги.
    * Выводит строку и текущее число.
    * @author Брюс Эккель
    * @author www.MindView.net
    * @version 4.0
    */
    public class HelloDate {
        /** Точка входа в класс и приложение
        * @param args Массив строковых аргументов
        * @throws exceptions Исключения не выдаются
        */
        public static void main(String[] args) {
            System.out.println("Привет, сегодня: ");
            System.out.println(new Date());
        }
    } /* Output. (55% match)
    Привет. сегодня.
    web Oct 05 14:39:36 MDT 2005
    */// ~
    </pre>

В первой строке файла использована моя личная методика помещения специального маркера <code>//:</code> в
комментарий как признака того, что в этой строке комментария содержится имя файла с исходным текстом. Здесь
указывается путь к файлу (object означает эту главу) с последующим именем файла. Последняя строка также завершается
комментарием <code>(///:~)</code>, обозначающим конец исходного текста программы. он помогает автоматически
извлекать из текста книги программы для проверки компилятором и выполнения.

Тег <code>/* Output:</code> обозначает начало выходных данных, сгенерированных данным файлом. В этой форме их можно
автоматически проверить на точность.
</p>

	<h2>Стиль оформления программ</h2>
	<p>
		Согласно правилам стиля, описанным в руководстве
		<i>Code Conventions for the Java Programming Language,
			<sup>
				1
				<span hidden="">Находится по адресу java.sun.com/docs/codeconv/index.html</span>
			</sup>
		</i>
		имена классов должны записываться с прописной буквы. Если имя состоит из нескольких слов, они объединяются (то
		есть символы подчёркивания не используются для разделения), и каждое слово в имени начинается с большой буквы:

		<pre>
		class AllTheColorsOfTheRainbow { // ..
		</pre>

		Практически для всего остального: методов, полей и ссылок на объекты - используется такой же способ записи,
		за <code>одним исключением</code> - первая буква идентификатора записывается строчной. Например:

		<pre>
		class AllTheColorsOfTheRainbow {
			int anIntegerRepresentingColors;
			void changeTheHueOfTheColor(int, newHue) {
				// ..
			}
			// .
		}
		</pre>

		Помните, что пользователю ваших классов и методов придётся вводить все эти длинные имена, так что будьте милосердны.

		В исходных текстах Java, которые можно увидеть в библиотеках фирмы Sun, также используется схема размещения
		открывающих и закрывающих фигурных скобок, которая встречается в примерах данной книги.
	</p>

	<h2>Резюме</h2>
	<p>
		В этой главе я постарался привести информацию о программировании на Java, достаточную для написания самой
		простой программы. Также был представлен обзор языка и некоторых его основных свойств. Однако примеры до сих пор
		имели форму "сначала это, потом это, а после что-то ещё". В следующих двух главах будет представлены основные
		операторы, используемые при программировании на Java, а также способы передачи управления в вашей программе.
	</p>

	<h1>Операторы 3</h1>
	<p>
		<i>На нижем уровне операции с данными в Java осуществляются посредством операторов.</i>

		Язык Java создавался на основе C++, поэтому большинство этих операторов и конструкций знакомы программистам на
		C и C++. Также в Java были добавлены некоторые улучшения и упрощения. Если вы знакомы с синтаксисом C или C++,
		бегло просмотрите эту следующую главу, останавливаясь на тех местах, в которых Java отличается от этих языков.
		Если чтение даётся вам с трудом, попробуйте обратиться к мультимедийному семинару <i>Thinking in C</i>,
		свободно загружаемому с сайта www.MindView.net. Он содержит аудио-лекции, слайды, упражнения и решения,
		специально разработанные для быстрого ознакомления с синтаксисом C, необходимым для успешного овладевания
		языком Java.
	</p>

	<h2>Простые команды печати</h2>
	<p>
		В предыдущей главе была представлена команда печати Java

		<pre>
		System.out.println("Какая длинная команда...");
		</pre>

		Вероятно, вы заметили, что команда не только получается слишком длинной, но и плохо читается. Во многих языках
		до и после Java используется более простой подход к выполнению столь распространённой операции.

		В главе 6 представлена концепция <i>статического импорта</i>, появившаяся в Java SE5, а также крошечная
		библиотека, упрощающая написание команд печати. Тем не менее для использования библиотеки не обязательно знать
		все подробности. Программу из предыдущей главы можно переписать в следующем виде:

		<pre>
		// operators/HelloDate java
		import java util.*;
		import static.net.mindview.util Print.*;

		public class HelloDate {
			public static void main(String[] args) {
				print("Привет. сегодня: ");
				print(new Date());
			}
		} /* Output: (55% match)
		Привет. сегодня
		Wed Oct 05 14:39:36 MDT 2005
		*///:~
		</pre>

		Результат смотрится гораздо приятнее. Обратите внимание на ключевое слово static во второй команде import.
		Чтобы использовать эту библиотеку, необходимо загрузить архив с примерами кода. Распакуйте его и включите
		корневой каталог дерева в переменную окружения CLASSPATH вашего компьютера. Хотя использование
		<code>net.mindview.util.Print</code> упрощает программный код, оно оправданно не везде. Если программа содержит
		небольшое количество команд печати, я отказываюсь от import и записываю полный вызов <code>System.out.pringln()</code>.
	</p>

	<h2>Операторы Java</h2>
	<p>
		Оператор получает один или несколько аргументов и создаёт на их основе новое значение. Форма передачи аргументов
		несколько иная, чем при вызове метода, но эффект тот же самый. Сложение (+), вычитание и унарный минус (-),
		умножение (*), деление (/) и присвоение (=) работают одинаково фактически во всех языках программирования.

		Все операторы работают с операндами и выдают какой-то результат. Вдобавок некоторые операторы могут изменить
		значение операнда. Это называется <i>побочным эффектом</i>. Как правило, операторы, изменяющие значение своих
		операндов, используются именно ради побочного эффекта, но вы должны помнить, что полученное значение может быть
		использовано в программе и обычным образом, независимо от побочных эффектом.

		Почти все операторы работают только с примитивами. Исключениями являются =, == и !=, которые могут быть
		применены к объектам (и создают немало затруднений). Кроме того, класс String поддерживает операции + и +=.
	</p>

	<h2>Приоритет</h2>
	<p>
		Приоритет операций определяет порядок вычисления выражений с несколькими операторами. В Java существуют
		конкретные правила для определения очерёдности вычислений. Легче всего запомнить, что деление и умножение
		выполняются раньше сложения и вычитания. Программисты часто забывают правила предшествования, поэтому для
		явного задания порядка вычислений следует использовать круглые скобки. Например, взгяните на команды (1) и (2):

		<pre>
		// operators/Precedence java

		public class Precedence {
			public static void main(String[] args) {
				int x = 1, y = 2, z = 3; // (1)
				int b = x + (y - 2) / (2 + z); // (2)
				System.out.println("a = " + a + " b =" + b);
			}
		} /* Output
		a = 5 b = 1
		*///: ~
		</pre>

		Команды похожи друг на друга, но из результатов хорошо видно, что они имеют разный смысл в зависимости от
		присутствия круглых скобок.

		Обратите внимание на оператор + в команде System.out.println. В данном контексте + означает конкатенацию строк,
		а не суммирование. Когда компилятор встречает объект String, за которым следует + и объект, отличный от String,
		он пытается преобразовать последний объект в String. Как видно из выходных данных, для a и b тип int был успешно
		преобразован в String.
	</p>

	<h2>Присвоение</h2>
	<p>
		Присвоение выполняется оператором =. Трактуется он так: "взять значение из правой части выражения (часто
		называемое просто <i>значением</i> и скопировать его в левую часть (часто называемую <i>именующим выражением)</i>".
		Значением может быть любая константа, переменная или выражение, но в качестве именующего выражения
		обязательно должна использоваться именованная переменная (то есть для хранения значения должна выделяться
		физическая память). Например, вы можете присвоить постоянное значение переменной:

		<pre>
		a = 4
		</pre>

		но нельзя присвоить что-либо константе - она не может использоваться в качестве именующего выражения (например,
		запись 4 = a недопустима).

		Для примитивов присвоение выполняется тривиально. Так как примитивный тип хранит данные, а не ссылку на объект,
		то присвоение сводится к простому копированию данных из одного места в другое. Например, если команда
		<code>a = b</code> выполняется для примитивных типов, то содержимое <code>b</code> просто копируется в <code>a</code>.
		Естественно, последующие изменения <code>a</code> никак не отражаются на <code>b</code>. Для программиста
		именно такое поведение выглядит наиболее логично.

		При присвоении объектов всё меняется. При выполнении операций с объектом вы в действительности работаете со
		ссылкой, поэтому присвоение "одного объекта другому" на самом деле означает копирование ссылки из одного места
		в другое. Это значит, что при выполнении команды <code>c = d</code> для объектов в конечном итоге <code>c</code>
		и <code>d</code> указывают на один объект, которому изначально соответствовала только ссылка <code>d</code>.
		Сказанное демонстрирует следующий пример:

		<pre>
		//: operators/Assignment java
		// Присвоение объектов имеет ряд хитростей
		import static net.mindview.util Print.*;

		class Tank {
			int level;
		}

		public class Assignment {
			public static void main(String[] args) {
				Tank t1 = new Tank();
				Tank t2 = new Tank();
				t1 level = 9;
				t2 level = 47;
				print("1: t1 level " + t1 level +
					". t2 level " + t2 level);
				t1 = t2;
				print("2: t1 level " + t1 level +
					". t2.level " + t2 level);
				t1.level = 27;
				print("3: t1.level " + t1 level +
					". t2.level " + t2 level);
			}
		} /* Output
		1 t1 level: 9, t2.level: 47
		2 t1 level: 47, t2 level: 47
		3 t1.level: 27, t2 level: 27
		*///:~
		</pre>

		Класс Tank предельно прост, и два его экземпляра (t1 и t2) создаются внутри метода main(). Переменной level
		для каждого экземпляра придаются различные значения, а затем ссылка <code>t2</code> присваивается <code>t1</code>,
		в результате чего <code>t1</code> изменяется.

		Во многих языках программирования можно было ожидать, что <code>t1</code> и <code>t2</code> будут независимы
		всё время, но из-за присвоения ссылок изменение объекта <code>t1</code> отражается на объекте <code>t2</code>!
		Это происходит из-за того, что <code>t1</code> и <code>t2</code> содержат одинаковые ссылки, указывающие на один
		объект. (Исходная ссылка, которая содержалась в <code>t1</code> и указывала на объект со значением 9, была
		перезаписана во время присвоения и фактически потеряна; её объект будет вскоре удалён сборщиком мусора.)

		Этот феномен совмещения имён часто называют <i>синонимией</i> (aliasing), и именно она является основным способом
		работы с объектами в Java. Но что делать, если совмещение имён нежелательно? Тогда можно пропустить присвоение
		и записать

		<pre>
			t1.level = t2 level;
		</pre>

		При этом программа сохранит два разных объекта, а не "выбросит" один из них, "привязав" ссылки <code>t1</code>
		и <code>t2</code> к единственному объекту. Вскоре вы поймёте, что прямая работа с полями данных внутри объектов
		противоречит принципам объектно-ориентированной разработки. Впрочем. это непростой вопрос, так что пока вам
		достаточно запомнить, что присвоение объектов может таить в себе немало сюрпризов.
	</p>

	<h2>Совмещение имён во время вызова методов</h2>
	<p>
		Совмещение имён также может происходить при передаче объекта методу:

		<pre>
		// operators/PassObject java
		// Передача объектов методам может работать
		// не так, как вы привыкли

		import static net.mindview.util.Print.*;

		class Letter {
			char c;
		}

		public class PassObject {
			static void f(Letter y) {
				y.c = 'z';
			}
			public static void main(String[] args) {
				Letter x = new Letter();
				x.c = 'a';
				print("1: x.c: " + x.c);
				f(x);
				print("2: x.c: " + x.c);
			}
		} /* Output
		1: x.c: a
		2: x.c: z
		*/ ///:~
		</pre>

		Во многих языках программирования метод f() создал бы копию своего параметра <code>Letter y</code> внутри своей
		области действия. Но из-за передачи ссылки строка

		<pre>
		y.c = 'z';
		</pre>

		на самом деле изменяет объект за пределами метода f().

		Совмещение имён и решение этой проблемы - сложные темы. Будьте очень внимательными в таких случаях во избежание
		ловушек.
	</p>

	<h2>Арифметические операторы</h2>
	<p>
		Основные математические операторы остаются неизменными почти во всех языках программирования: сложение (+),
		вычитание (-), деление (/), умножение (*) и остаток от деления нацело (%). Деление нацело обрезает, а не округляет
		результат.

		В Java также используется укороченная форма записи для того, чтобы одновременно произвести операцию и присвоение.
		Она обозначается оператором с последующим знаком равенства и работает одинаково для всех операторов языка (когда
		в этом есть смысл). Например, чтобы прибавить 4 к переменной <code>x</code> и присвоить результат <code>x</code>,
		используйте команду <code>x += 4</code>.

		Следующий пример демонстрирует использование арифметических операций

		<pre>
		//: operators/MathOps.java
		// Демонстрация математических операций.
		import java.util.*;
		import static net.mindview.util.Print.*;

		public class MathOps {
			public static void main(String[] args) {
				// Создание и раскрутка генератора случайных чисел
				Random rand = new Random(47);
				int i, j, k;
				// Выбор значения от 1 до 100;
				J = rand.nextInt(100) + 1;
				print("j : " + j);
				k = rand.nextInt(100) + 1;
				print("k : " + k);
				i = J + k;
				print("j + k : " + i;
				i = J - k;
				print("j - k : " + i);
				i = k / J;
				print("k / J : " + i);
				i = k * J;
				print("k * J : " + i);
				i = k % J;
				print("k % J : " + i);
				J % k;
				print("J % k : " + j);
				// Тесты для вещественных чисел
				float u, v, w; // также можно использовать double
				v = rand.nextFloat();
				print("v : " + v);
				w = rand.nextFloat()'
				print("w : " + w);
				u = v + w;
				print("v + w : " + u);
				u = v - w;
				print("v - w : " + u);
				u = v * w;
				print("v * w : " + u);
				u = v / w;
				print("v / w : " + u);
				// следующее также относится к типам
				// char, byte, short, int, long и double;
				u += v;
				print("u += v : " + u);
				u -= v;
				print("u -= v : " + u);
				u *= v;
				print("u *= v : " + u);
				u /= v;
				print("u /= v : " + u);
			}
		} /* Output:
		j : 59
		k : 56
		j + k : 115
		j - k : 3
		k / j : 0
		k * j : 3304
		k % j : 56
		j %= k : 3
		v : 0.5309454
		w : 0.0534122
		v + w : 0.5843576
		v - w : 0.47753322
		v * w : 0.02835862
		v / w : 9.940527
		u += v : 10.471473
		u -= v : 9.940527
		u /= v : 9.940527
		</pre>

		Для получения случайных чисел создаётся объект Random. Если он создаётся без параметров, Java использует текущее
		время для раскрутки генератора, чтобы при каждом запуске программы выдавались разные числа.

		Программа генерирует различные типы случайных чисел, вызывая соответствующие методы объекта
		<code>Random: nextInt()</code> и <code>nextFloat()</code> (также можно использовать <code>nextLong()</code>
		<code>nextDouble())</code>. Аргумент <code>nextInt()</code> задаёт верхнюю границу границу генерируемых чисел.
		Нижняя граница равна 0, но для предотвращения возможного деления на 0 результат смещается на 1.
	</p>

	<h2>Унарные операторы плюс и минус</h2>
	<p>
		Унарные минус (-) и плюс (+) внешне не отличаются от аналогичных бинарных операторов. Компилятор выбирает нужный
		оператор в соответствии с контекстом использования. Например, команда

		<pre>
		x = -a;
		</pre>

		имеет очевидный смысл. Компилятор без труда разберётся, что значит

		<pre>
		x = a * (-b);
		</pre>

		но читающий код может запутаться, так что яснее будет написать так:

		<pre>
		x = a * (b);
		</pre>

		Унарный минус меняет знак числа на противоположный. Унарный плюс существует "для симметрии", хотя и не производит
		никаких действий.
	</p>

	<h2>Авто-увеличение и авто-уменьшение</h2>
	<p>
		В Java, как и в C, существует множество различных сокращений. Сокращения могут упростить написание кода, а
		также упростить или усложнить его чтение.

		Два наиболее полезных сокращения - это операторы увеличения (инкремента) и уменьшения (декремента) (также часто
		называемые операторами автоматического приращения и уменьшения). Оператор декремента записывается в виде
		<code>--</code> и означает "уменьшить на единицу". Оператор инкремента обозначается символами <code>++</code>
		и позволяет "увеличить на единицу". Например, если переменная <code>a</code> является целым числом, то выражение
		<code>++a</code> будет эквивалентно <code>(a = a + 1)</code>. Операторы инкремента и декремента не только
		изменяют переменную, но и устанавливают ей в качестве результата новое значение.

		Каждый из этих операторов существует в двух версиях - <i>префиксной</i> и <i>постфиксной</i>. Префиксный инкремент
		значит, что оператор <code>++</code> записывается перед переменной или выражением, а при постфиксном инкременте
		оператор следует после переменной или выражения. Аналогично, при префиксном декременте оператор <code>--</code>
		указывается перед переменной или выражением, а при постфиксном - после переменной или выражения. Для префиксного
		инкремента и декремента (то есть <code>++a</code> и <code>--a</code> сначала выполняется операция, а затем
		выдаётся результат. Для постфиксной записи (<code>a++</code> и <code>a--</code>) сначала выдаётся значение, и
		лишь затем выполняется операция. Например:

		<pre>
		// operators/AutoInc java
		import static net.mindview.util.Print.*;

		public Class AutoInc {
			public static void main(String[] args) {
				int i = l;
				print("i : " + i);
				print("++i : " + ++i); // Префиксный инкремент
				print("i++ : " " i++); // Постфиксный инкремент
				print("i : " + i);
				print("--i : " + --i); // Префиксный декремент
				print("i-- : " " i--); // Постфиксный декремент
				print("i : " + i);
			}
		} /* Output
		i : l
		++i : 2
		i++ : 2
		i : 3
		--i : 2
		i-- : 2
		i : l
		*///:~
		</pre>

		Вы видите, что при использовании префиксной формы результат получается после выполнения операции, тогда как с
		постфиксной формой он доступен до выполнения операции. Это единственные операторы (кроме операторов присваивания),
		которые имеют побочный эффект. (Иначе говоря, они изменяют свой операнд вместо простого использования его
		значения.)

		Оператор инкремента объясняет происхождение названия языка <code>C++</code>; подразумевается "шаг вперёд по
		сравнению с <code>C</code>". В одной из первых речей, посвящённых Java, Билл Джой (один из его создателей)
		сказал, что "Java = C++--". Он имел в виду, что Java - это C++, из которого убрано всё, что затрудняет
		программирование, и поэтому язык стал гораздо проще. Продвигаясь вперёд, вы увидите, что отдельные аспекты
		языка, конечно, проще, и всё же Java не <i>настолько</i> проще C++.
	</p>

	<h2>Операторы сравнения</h2>
	<p>
		Операторы сравнения выдают логический (boolean) результат. Они проверяют, в каком отношении находятся значения
		их операндов. Если условие проверки истинно, оператор выдаёт <code>true</code>, а если ложно - <code>false</code>.
		К операторам сравнения относятся следующие: "меньше чем" (<), "больше чем" (>), "меньше чем или равно" (<=),
		"больше чем или равно" (>=), "равно" (==) и "не равно" (!=). "Равно" () и "не равно" (!=). "Равно" и "не равно"
		работают для всех примитивных типов данных, однако остальные сравнения не применимы к типу boolean.
	</p>

	<h2>Проверка на равенство</h2>
	<p>
		Операции отношений == и != также работают с любыми объектами, но их смысл нередко сбивает с толку начинающих
		программистов на Java. Пример:

		<pre>
		//: operators/AutoInc.java

		public class Equivalence {
			public static void main(String[] args) {
				Integer n1 = new Integer(47);
				Integer n2 = new Integer(47);
				System.out.println(n1 == n2);
				System.out.println(n1 != n2);
			}
		} /* Output.
		false
		true
		*///:~
		</pre>

		Выражение <code>System.out.println(n1 == n2)</code> выведет результат логического сравнения, содержащегося в
		скобках. Казалось бы в первом случае результат должен быть истинным (true), а во втором - ложным (false),
        так как оба объекта типа Integer имеют одинаковые значения. Но в то время как содержимое объекта одинаково,
        ссылки на них разные, а операторы != и == сравнивают именно ссылки. Поэтому результатом первого выражения
        будет false, а второго - true. Естественно, такие результаты поначалу ошеломляют.

        А если понадобится сравнить действительное содержимое объектов? Придётся использовать специальный метод
        <code>equals()</code>, поддерживаемый всеми объектами (но не примитивами, для которых более чем достаточно
        операторов == и !=). Вот как это делается:

        <pre>
        //: operators/EqualsMethod.java

        public class EqualsMethod {
            public static void main(String[] args) {
                Integer n1 = new Interger(47);
                Integer n2 = new Interger(47);
            }
        } /* Output
        true
        *///:~
        </pre>

        На этот раз результат окажется "истиной" (true), как и предполагалось. Но всё не так просто, как кажется.
        Если вы создадите свой собственный класс вроде такого:

        <pre>
        //: operators/EqualsMethod2 java
        // Метод equals() по умолчанию не сравнивает содержимое

        class Value {
            int i;
        }

        public class EqualsMethod2 {
            public static void main(String[] args) {
                Value v1 = new Value();
                Value v2 = new Value();
                V1.i = v2.i = 100;
                System.out.println(v1, equals(v2));
            }
        } /* Output
        false
        *///:~
        </pre>

        мы вернёмся к тому, с чего начали: результат будет false. Дело в том, что метод equals() по умолчанию
        сравнивает ссылки. Следовательно, пока вы не <i>переопределите</i> этот метод в вашем новом классе, не
        получите желаемого результата. К сожалению, переопределение будет рассматриваться только в главе 8,
        а пока осторожность и общее понимание принципа работы equals() позволит избежать некоторых неприятностей.

        Большинство классов библиотек Java реализуют метод equals() по-своему, сравнивая содержимое объектов, а не
        ссылки на них.
	</p>

    <h2>Логические операторы</h2>
    <p>
        Логические операторы <code>И &&</code>, <code>ИЛИ (||)</code> и <code>НЕ (!)</code> производят логические
        значения true и false, основанные на логических отношениях своих аргументов. В следующем примере используются
        как операторы сравнения, так и логические операторы:

        <pre>
        //: operators/Bool.java
        // Операторы сравнений и логические операторы.
        import java.util.*;
        import static net.mindview.util.Print.*;

        public class Bool {
            public staic void main(String[] args) {
                Random rand = new Random(47);
                int i = rand.nextInt(100);
                int j = rand.nextInt(100);
                print("i = " + i);
                print("j = " + j);
                print("i > j is " + (i > j));
                print("i < j is " + (i < j));
                print("i => j is " + (i => j));
                print("i <= j is " + (i <= j));

                print("i == j is " + (i == j));
                print("i != j is " + (i != j));
                // В Java целое число (int) не может
                // интерпретироваться как логический тип (Boolean)
                //! print("i && j is " + (i && j));
                //! print("i || j is " + (i || j));
                //! print("!i is " + !i);
                print("(i < 10) && (j < 10) is "
                    + ((i < 10) && (j < 10)));

                print("(i < 10) || (j < 10) is "
                    + ((i < 10) || (j < 10)));
            }
        } /* Output:
        i = 58
        j = 55
        i > j is true
        i < j is false
        i >= j is true
        i <= j is false
        i == j is false
        i != j is true
        (i < 10) && (j < 10) is false
        (i < 10) || (j < 10) is false
        *///:~
        </pre>

    Операции <code>И, ИЛИ</code> и <code>НЕ</code> применяются только к логическим (boolean) значениям. Нельзя
    использовать в логических выражениях <code>не-boolean-типы</code> в качестве булевых, как это разрешается в C и
    C++. Неудачные попытки такого рода видны в строках, помеченных особым комментарием <code>//!</code> (этот синтакcис
    позволяет автоматически удалять комментарии для удобства тестирования). Последующие выражения вырабатывают логические
    результаты, используя операторы сравнений, после чего к полученным значениям применяются логические операции.

    Заметьте, что значение <code>boolean</code> автоматически переделывается в подходящее строковое представление там,
    где предполагается использование строкового типа String.

    Определение int в этой программе можно заменить любым примитивным типом, за исключением boolean. Впрочем, будьте
    осторожны с вещественными числами, поскольку их сравнение проводится с крайне высокой точностью. Число, хотя бы
    чуть-чуть отличающееся от другого, уже считается неравным ему. Число, на тысячную долю большее нуля, уже не является
    нулём.
    </p>

	<h2>Ускоренное вычисление</h2>
	<p>
		При работе с логическими операторами можно столкнуться с феноменом, называемым "ускоренным вычислением". Это
		значит, что выражение вычисляется только до тех пор, пока не станет очевидно, что оно принимает значение
		"истина" или "ложь". В результате, некоторые части логического выражения могут быть проигнорированы в процессе
		сравнения. Следующий пример демонстрирует ускоренное вычисление:

		<pre>
		// operators/ShortCircuit.java
		// Демонстрация ускоренного вычисления
		// при использовании логических операторов.
		import static net.mindview.util.Print.*;

		public class ShortCircuit {
			static boolean test1(int, val) {
				print("test1(" + val + ")");
				print("результат: " + (val < 1));
				return val < 1;
			}
			static boolean test2(int, val) {
				print("test2(" + val + ")");
				print("результат: " + (val < 2));
				return val < 2;
			}
			static boolean test3(int, val) {
				print("test3(" + val + ")");
				print("результат: " + (val < 3));
				return val < 3;
			}
			public static void main(String[] args) {
				boolean b = test1(0) && test2(2) && test3(2);
				print ("выражение: " + b);
			}
		} /* Output:
		test1(0)
		результат: true
		test2(2)
		результат: false
		выражение: false
		*///:~
		</pre>

		Каждый из методов test() проводит сравнение своего аргумента и возвращает либо true, либо false. Также они
		выводят информацию о факте своего вызова. Эти методы используются в выражении

		<pre>
			test1(0) && test2(2) && test3(2)
		</pre>

		Естественно было бы ожидать, что все три метода должны выполняться, но результат программы показывает другое.
		Первый метод возвращает результат true, поэтому вычисление выражения продолжается. Однако второй метод выдаёт
		результат false. Так как это автоматически означает, что все выражение будет равно false, зачем продолжать
		вычисления? Только лишняя трата времени. Именно это и стало причиной введения в язык ускоренного вычисления;
		отказ от лишних вычислений обеспечивает потенциальный выигрыш в производительности.
	</p>

	<h2>Литералы</h2>
	<p>
		Обычно, когда вы записываете в программе какое-либо значение, компилятор точно знает, к какому типу оно относится.
		Однако в некоторых ситуациях однозначно определить тип не удаётся. В таких случаях следует помочь компилятору
		определить точный тип, добавив дополнительную информацию в виде определённых символьных обозначений, связанных
		с типами данных. Эти обозначения используются в следующей программе:

		<pre>
		//: operators/Literals.java
		import static net.mindview.util.Print.*;

		public class Literals {
			public static void main(String[] args) {
				int i1= 0x2f; //Шестнадцатеричное (нижний регистр)
				print("i1: " + Integer.toBinaryString(i1));

				int i2 = 0X2f; // Шестнадцатеричное (верхний регистр)
				print("i2: " + Integer.toBinaryString(i2));

				int i3 = 0177; // Восьмеричное (начинается с нуля)
				print("i3: " + Integer.toBinaryString(i3));

				char c = 0xffff; // макс. шестнадцатеричное знач. char
				print("c: " + Integer.toBinaryString(c));

				byte b = 0x7f; // акс шестнадцатеричное знач. byte
				print("b " + Integer toBinaryString(b));

				short s = 0x7fff; // макс. шестнадцатеричное знач. short
				print("s " + Integer.toBinaryString(b));

				long n1 = 200L; // Суффикс, обозначающий long
				long n2 = 200l, // Суффикс, обозначающий long (можно запутаться)
				long n3 = 200;

				float f1 = 1;
				float f2 = 1F; // Суффикс, обозначающий float
				float f3 = 1f; // Суффикс, обозначающий float

				double d1 = 1d; // Суффикс, обозначающий double
				double d2 1 1D; // Суффикс, обозначающий double
			}
		} /* Output
		i1: 101111
		i2: 101111
		i3: 1111111
		c: 1111111111111111
		b: 1111111
		s: 111111111111111
		*///:~
		</pre>

		Последний символ обозначает тип записанного литерала. Прописная или строчная буква <code>L</code> определяет
		тип <code>long</code> (впрочем, строчная <code>l</code> может создать проблемы, потому что она похожа на цифру
		<code>1)</code>; приписная или строчная <code>F</code> соответствует типу <code>float</code>, а заглавная или
		строчная <code>D</code> подразумевает тип <code>double</code>.

		Шестнадцатеричное представление (основание 16) работает со всеми встроенными типами данных и обозначается
		префиксом <code>0x</code> или <code>0X</code> с последующим числовым значением из цифр <code>0-9</code> и
		букв <code>a-f</code>, присных или строчных. Если при определении переменной задаётся значение, превосходящее
		максимально для неё возможное (независимо от числовой формы), компилятор сообщит вам об ошибке. В программе
		указаны максимальные значения для типов <code>char, byte</code> и <code>short</code>. При выходе за эти границы
		компилятор автоматически сделает значение типом <code>int</code> и сообщит вам, что для присвоения понадобится
		сужающее приведение.

		Восьмеричное представление (по основанию 8) обозначается начальным нулём в записи числа, состоящего из цифр
		от 0 до 7. Для литеральной записи чисел в двоичном представлении в Java, C и C++ поддержки нет. Впрочем, при
		работе с шестнадцатеричными и восьмеричными числами, часто требуется получить двоичное представление результата.
		Задача легко решается методами <code>static toBinaryString()</code> классов <code>Integer</code> и
		<code>Long</code>.
	</p>
</body>
</html>