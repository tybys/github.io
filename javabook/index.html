<!DOCTYPE html>
<html>
<head lang="ru">
    <meta charset="UTF-8">
    <title></title>
    <style>

    </style>
</head>
<body>
<h1>Всё является объектом</h1>

<p>
    Хотя язык Java основан на C++, он является более "чистокровным" объектно-ориентированным языком.

    Как C++, так и Java относятся к семейству смешанных языков, но дял создателей Java эта неоднородность
    была не так важна, если сравнивать с C++. Смешанный язык позволяет использовать несколько стилей
    программирования; причиной смешанной природы C++ стало желание сохранить совместимость с языком C.
    Так как язык C++ является надстройкой языка C, он включает в себя много нежелательных характеристик своего
    предшественника, что приводит к излишнему усложнению некоторых аспектов этого языка.

    Язык программирования Java подразумевает, что вы занимаетесь только объектно-ориентированным программированием.
    А это значит, что прежде, чем начать с ним работать, нужно "переключится" на понятия объектно-ориентированного
    мира (если вы уже этого не сделали).

    Выгода от этого начального усилия - возможность программировать на языке, который по простоте изучения и
    пользования превосходит все остальные языки ООП. В этой главе мы рассмотрим основные Java-программы и узнаем,
    что в Java (почти) всё является объектом.
</p>

<h2>Для работы с объектами используются ссылки</h2>
<p>
    Каждый язык программирования имеет свои манипуляции данными. Иногда программисту приходится быть постоянно в
    курсе, какая именно манимуляция производится в программе. Вы работаете с самим объектом или же с каким-то
    видом его косвенного представления (указатель в C или в C++), требующим особого синтаксиса?

    Все эти различия упрощены в Java. Вы обращаетесь со всем как с объектом, и поэтому повсюду используется единый
    последовательный синтаксис. Хотя вы обращаетесь со всем как с объектом, идентификатор, которым вы манипулируете,
    на самом деле представляет собой ссылку на объект<sup>1</sup>. Представьте себе телевизор (объект) с пультом
    дистанционного управления (ссылка). Во время владения этой ссылкой у вас имеется связь с телевизором,
    но при переключении канала или уменьшении громкости вы распоряжаетесь ссылкой, которая в свою очередь,
    манипулирует объектов. А если вам захочется перейти в другое место комнаты, все еще управляя телевизором, вы
    берёте с собой "ссылку", а не сам телевизор.

    Также пульт может существовать сам по себе, без телевизора. Таким образом, сам факт наличия ссылки еще не
    означает наличия присоединенного к ней объекта. Например, для хранения слова или предложения создается ссылка

    <pre>
        String:
            String s;
    </pre>

    Однако здесь определяется <i>только</i> ссылка, но не объект. Если вы решите послать сообщение s, произойдёт
    ошибка, потому что ссылка s на самом деле ни к чему не присоединена (телевизора нет). Значит, безопаснее всегда
    инициализировать ссылку при её создании:

    <pre>
        String s = "asdf";
    </pre>

    В данном примере используется специальная возможность Java: инициализация строк текстом в кавычках. Обычно вы
    будете использовать более общий способ инициализации объектов.
</p>

<h2>Все объекты дожны создаваться явно</h2>
<p>
    Когда вы определяете ссылку, желательно присоеденить её к новому объекту. В основном это делается при помощи
    ключевого слова new. Фактически оно означает: "Создайте мне новый объект". В предыдущем примере можно написать:

    <pre>
        String s = new String("asdf");
    </pre>

    Это не только значит "предоставьте мне новый объект String", но также казывает, как создать строку посредством
    передачи начального набора символов.

    Конечно, кроме String, в Java имеется множество готовых типов. Важнее то, что вы можете создавать свои
    собственные типы. Вообще говоря, именно создание новых типов станет вашим основным занятием при программировании
    на Java, и именно его мы будет рассматривать в книге.
</p>
<h2>Где хранятся данные</h2>
<p>
    Полезно отчётливо представлять, что происходит во время работы программы - и в частности, как данные
    размещаются в памяти. Существует пять разных мест для хранения данных:

    <ol>
        <li>
            <strong>Регистры.</strong> Это самое быстрое хранилище, потому что данные хранятся прямо внутри
            процессора. Однако количество регистров жестко ограничено, поэтому регистры используются компилятором
            по мере необходимости. У вас нет прямого доступа к регистрам, вы не сможете найти и малейших следов их
            поддержки в языке. (С другой стороны, языки C и C++ позволяют порекомендовать компилятору данные
            в регистрах.)
        </li>
        <li>
            <strong>Стек.</strong> Эта область хранения данных находится в общей оперативной памяти (RAM), но
            процессор предоставляет прямой доступ к ней с использованием <i>указателя стека.</i> Указатель стека
            перемещается вниз для выделения памяти или вверх для её освобождения. Это чрезвычайно быстрый и
            эффективный способ размещения данных, по скорости уступающий только регистрам. Во время обработки
            программы компилятор Java должен знать жизненный цикл данных, размещаемых в стеке. Это ограничение
            уменьшает гибкость ваших программ, поэтому, хотя некоторые данные Java хранятся в стеке (особенно ссылки
            на объекты), сами объекты Java не помещаются в стек.
        </li>
        <li>
            <strong>Куча.</strong> Пул памяти общего назначения (находится также в RAM), в котором размещаются все
            объекты Java. Преимущество кучи состоит в том, что компилятору не обязательно знать, как долго
            просуществуют находящиеся там объекты. Таким образом, работа с кучей даёт значительное преимущество
            в гибкости. Когда вам нужно создать объект, вы пишете код с использованием new, и память выделяется из
            кучи во время выполнения программы. Конечно, за гибкость приходится расплачиваться: выделение памяти
            из кучи занимает больше времени, чем в стеке (даже если вы <i>могли</i> явно создавать объекты в стеке,
            как в C++).
        </li>
        <li>
            <strong>Постоянная память.</strong> Значения констант часто встраиваются прямо в код программы,
            так как они неизменны. Иногда такие данные могут размещать в постоянной памяти (ROM), если речь идёт о
            "встроенных" системах.
        </li>
        <li>
            <strong>Не-оперативная память.</strong> Если данные располагаются вне программы, они могут существовать
            и тогда, когда она ен выполняется. Два основных примера: <i>потоковые объекты</i> (streamed objects),
            в которых объекты представлены в виде потока байтов, обычно используются для посылки на другие машины,
            и <i>долгоживущие</i> (persistent) <i>объекты</i>, которые запоминаются на диске и сохраняют своё
            состояние даже после окончания работы программы. Особенностью этих видов хранения данных является
            возможность перевода объектов в нечто, что может быть сохранено на другом носителе информации,
            а потом восстановлено в виде обычного объекта, хранящегося в оперативной памяти. В Java организована
            поддержка <i>легковесного</i> (lightweight) <i>сохранения состояния,</i> а такие механизмы, как JDBC и
            Hibernate, предоставляют более совершенную поддержку сохранения и выборки информации об объектах из баз
            данных.
        </li>
    </ol>
</p>
<!--50-->

<h2>Особый случай: примитивные типы</h2>
<p>
    Одна из групп типов, часто применяемых при программировании, требует особого обращения. Их можно назвать
    "примитивными" типами (табл. 2.1). Причина для особого обращения состоит в том, что создание объекта с помощью
    new - особенно маленькой простой переменной - недостаточно эффективно, так как new помещает объекты в кучу.
    В таких случаях Java следует примеру языков C и C++. То есть вместо создания переменной с помощью new создается
    "автоматическая" переменная, <i>не являющаяся ссылкой.</i> Переменная напрямую хранит значение и располагается в
    стеке, так что операции с ней гораздо производительнее.

    В Java размеры всех примитивных типов жёстко фиксированы. Они не меняются с переходом на иную машинную
    архитектуру, как это происходит во многих других языках. Незыблемость размера - одна из причин улучшенной
    переносимости Java-программ.

    <h3><strong>Таблица 2.1.</strong> Примитивные типы</h3>
    <table>

            <thead>
                <th>Примитивный тип</th>
                <th>Размер, бит</th>
                <th>Минимум</th>
                <th>Максимум</th>
                <th>Тип упаковки</th>
            </thead>


        <tr>
            <td>boolean (логические значения)</td>
            <td>-</td>
            <td>-</td>
            <td>-</td>
            <td>Boolean</td>
        </tr>
    </table>

    Все числовые значения являются знаковыми, так что не ищите слова unsigned.

    Размер типа boolean явно не определяется; указывается лишь то, что этот тип может принимать значения true и false.

    "Классы-обёртки" позволяют создать в куче не-примитивный объект для представления примитивного типа. Например:

    <pre>
        char c = 'x'.
        Character ch = new Character(c).
    </pre>
</p>
<!--51-->

<p>
    Также можно использовать такой синтаксис:

    <pre>
        Character ch = new Character('x');
    </pre>

    Механизм <i>автоматической упаковки</i> Java SE5 автоматически преобразует примитивный тип в объектную "обёртку":

    <pre>
        Character ch = 'x';
    </pre>

    и обратно

    <pre>
        char c = ch;
    </pre>

    Причины создания подобных конструкий будут объяснены в последующих главах.
</p>

<h2>Числа повышенной точности</h2>
<p>
    В Java существует два класса для проведения арифметических операций повышенной точности:
    <strong>BigInteger </strong>и <strong>BigDecimal</strong>.
    Хотя эти классы примерно подходят под определение "класс-обёрток", ни один из них не имеет аналога среди
    примитивных типов.

    Оба класса содержатметоды, производящие операции, аналогичные тем, что проводятся над примитивными типами. Иначе
    говоря, с классами <strong>BigInteger</strong> и <strong>BigDecimal</strong> можно делать то же, что с
    <strong>int</strong> или <stong>float</stong>, просто для этого используются вызовы методов, а не встроенные
    операции. Также из-за использования увеличенного объема данных операции занимают больше времени. Приходится
    жертвовать скоростью ради точности.

    Класс <strong>BigInteger</strong> поддерживает целые числа произвольной точности. Это значит, что вы можете
    использовать целочисленные значения любой величины без потери данных во время операций.

    Класс <strong>BigDecimal</strong> представляет числа с фиксированной запятой произвольной точности; например,
    они могут применяться для финансовых вычислений.

    За подробностями о конструкторах и методах этих классов обращайтесь в документацию JDK.
</p>

<h2>Массивы в Java</h2>
<p>
    Фактически все языки программирования поддерживают массивы. Использование массивов в C и C++ небезопасно, потому
    что массивы в этих языках представляют собой обычно блоки памяти. Если программа попытается получить доступ к
    массиву за пределами его блока памяти или использовать память без предварительной инициализации (типичные
    ошибки при программировании), последствия могут быть непредсказуемы.

    Одной из основных целей Java является безопасность, поэтому многие проблемы, досаждавшие программистам на C и C++,
    не существуют в Java. Массив в Java гарантированно инициализируется, к нему невозможен доступ за пределами его
    границ. Проверка границ массива обходится относительно дорого, как и проверка индекса во время выполнения, но
    предполагается, что повышение безопасности и подъём производительности стоят того (к тому же Java иногда
    может оптимизировать эти операции).
</p>
<!--52-->

<p>
    При объявлении массива объектов на самом деле создается массив ссылок, и каждая из этих ссылок автоматически
    инициализируется специальным значением, представленным ключевым словом <strong>null.</strong> Оно означает,
    что ссылка на самом деле не указывается на объект. Вам необходимо присоединять объект к каждой ссылке перед
    тем, как её использовать, или при попытке обращения по ссылке null во время исполнения программы произойдёт ошибка.
    Таким образом, типичные ошибки при работа с массивами в Java предотвращаются заблаговременно.

    Также можно создавать массивы простейших типов. И снова компилятор гарантирует инициализацю - выделенная для
    нового массива память заполняется нулями.

    Массивы будут подробнее описаны в последующих главах.
</p>

<h2>Объекты никогда не приходится удалять</h2>
<p>
    В большинстве языков программирования концепция жизненного цикла переменной требует относительно заметных
    усилий со стороны программиста. Сколько "живёт" переменная? Если её необходимо удалить, когда это следует делать?
    Путаница со сроками существования переменных может привести ко многим ошибкам, и этот раздел показывает, насколько
    Java упрощает решение затронутого вопроса, выполняя всю работу по удалению за вас.
</p>

<h2>Ограничение области действия</h2>
<p>
    В большинстве процедурных языков существует понятие <i>области действия</i> (scope). Область действия
    определяет как видимость, так и срок жизни имён, определенных внутри неё. В C, C++ и Java область действия
    устанавливается положением фигурных скобок {}. Например:

    <pre>
    {
        int x = 12;
        // доступно только x
        {
            int q = 96;
            // доступны как x, так и q
        }
        // доступно только x
        // q находится "за пределами видимости"
    }
    </pre>

    Переменная, определенная внутри области действия, доступна только в пределах этой области.

    Весь текст после символов // и до конца строки является комментарием.

    Отступы упрощают чтение программы на Java. Так как Java относится к языкам со свободным форматом,
    дополнительные пробелы, табуляция и переводы строк не влияют на результирующую программу.

    Учтите, что следующая конструкция <i>не разрешена</i>, хотя в C и C++ она возможна:
</p>
<!--53-->

<p>
    <pre>
        {
            int x = 12;
            {
                int x = 96; // неверно
            }
        }
    </pre>

    Компилятор объявит, что переменная x уже была определена. Таким образом, возможность языков C и C++ "прятать" переменные
    во внешней области действия не поддерживается. Создатели Java посчитали, что она приводит к излишнему усложнению программ.
</p>

<h2>Область действия объектов</h2>
<p>
    Объекты Java имеют другое время жизни в сравнеи с примитивами. Объект, созданный оператором Java <strong>new</strong>,
    будет доступен вплоть до конца области действия. Если вы напишите:

    <pre>
        {
            String s = new String("строка");
        } // конец области действия
    </pre>

    то ссылка s исчезнет в конце области действия. Однако объект String, на который указывала s, всё ещё будет занимать
    память. В показанном фрагменте кода невозможно получить доступ к объекту, потому что единственная ссылка вышла
    за пределы видимости. В следующих главах вы узнаете, как передаются ссылки на объекты и как их можно копировать во
    время работы программы.

    Благодаря тому, что объекты, созданные <strong>new</strong>, существуют ровно столько, сколько вам нужно, в Java
    исчезает целый пласт проблем, присущих C++. В C++ приходится не только следить за тем, чтобы объекты продолжали
    существовать на протяжении своего жизненного цикла, но и удалять объекты после завершения работы с ними.

    Возникает интересный вопрос. Если в Java объекты остаются в памяти, что же мешает им постепенно занять всю память
    и остановить выполнение программы? Именно это произошло бы в данном случае в C++. Однако в Java существует
    <i>сборщик мусора</i> (garbage collector), который наблюдает за объектами, созданными оператором <strong>new</strong>,
    и определяет, на какие из них больше нет ссылок. Тогда он освобождает память от этих объектов, которая становится
    доступной для дальнейшего использования. Таким образом, вам никогда не придётся "очищать" память вручную. Вы просто
    создаёте объекты, и как только надобность в них отпадёт, эти объекты исчезают сами по себе. При таком подходе
    исчезает целый класс проблем программирования: так называется "утечки памяти", когда программист забывает
    освобождать занятую память.
</p>

<h2>Создание новы типов данных</h2>
<p>
    Если всё является объектом, что определяет строение и поведение класса объектов? Другими словами, как устанавливается
    <i>тип</i> объекта? Наверное, для этой цели можно было бы использовать ключевое слово <strong>type</strong> ("тип");
    это было бы вполне разумно. Впрочем, с давних времён повелось, что большинство объектно-ориентированных языков
    использовали ключевое слово <strong>class</strong> в смысле "Я собираюсь описать новый тип объектов". За ключевым
    словом <strong>class</strong> следует имя нового типа. Например:

    <pre>
        class ATypeName { /* Тело класса */ }
    </pre>

    Эта конструкция вводит новый тип, и поэтому вы можете теперь создавать объект этого типа ключевым словом new:

    <pre>
        ATypeName a = new ATypeName();
    </pre>

    Впрочем, объекту нельзя "приказать" что-то сделать ( то есть послать ему необходимые сообщения) до тех пор,
    пока для него не будут определены методы.
</p>

<h2>Поля и методы</h2>
<p>
    При определении класса (строго говоря, вся ваша работа на Java сводится к определению классов, созданию объектов
    этих классов и посылке сообщений этим объектам) в него можно включить две разновидности элементов: <i>поля</i>
    (fields)(иногда называемые переменными класса) и <i>методы</i> (methods) (еще называемые функциями класса). Поле
    представляет собой объект любого типа, с которым можно работать по ссылке, или объект примитивного типа. Если
    используется ссылка, её необходимо инициализировать, чтобы связать с реальным объектом (ключевым словом new, как было
    показано ранее).

    Каждый объект использует собственный блок памяти для своих полей данных; совместное использование обычный полей
    разными объектами класса невозможно. Пример класса с полями:

    <pre>
        class DataOnly {
            int i;
            double d;
            boolean b;
        }
    </pre>

    Такой класс ничего не <i>делает</i>, кроме хранения данных, но вы можете создать объект этого класса:

    <pre>
        DataOnly data = new DataOnly();
    </pre>

    Полям класса можно присваивать значения, но для начала необходимо узнать, как обращаться к членам объекта. Для
    этого сначала указывается имя ссылки на объект, затем следует точка, а далее - имя члена, принадлежащего объекту:

    <pre>
        ссылка.член
    </pre>

    Например:

    <pre>
        data i = 47;
        data.d = 1.1;
        data.b = false;
    </pre>

    Также ваш объект может содержать другие объекты, данные которых вы хотели бы изменить. Для этого просто продолжите
    "цепочку из точек". Например:

    <pre>
        myPlane.leftTank.capacity = 100;
    </pre>

    Класс DataOnly не способен ни на что, кроме хранения данных, так как в нём отсутствуют методы. Чтобы понять, как
    они работают, необходимо разобраться, что такое <i>аргументы</i> и <i>возвращаемые значения</i>. Вскоре мы вернёмся
    к этой теме.
</p>

<h2>Значения по умолчанию для полей примитивных типов</h2>
<p>
    Если поле данных относится к примитивному типу, ему гарантировано присваивается значение по умолчанию, даже если
    оно не было инициализировано явно (табл. 2.2).

    <h3><strong>Таблица 2.2.</strong> Значения по умолчанию для полей примитивных типов</h3>
    <table>
        <thead>
            <td><strong>Примитивный тип</strong></td>
            <td><strong>Значение по умолчанию</strong></td>
        </thead>
        <tr>
            <td>boolean</td>
            <td>false</td>
        </tr>
        <tr>
            <td>char</td>
            <td>`\u0000` (null)</td>
        </tr>
        <tr>
            <td>byte</td>
            <td>(byte)0</td>
        </tr>
        <tr>
            <td>short</td>
            <td>(short)0</td>
        </tr>
        <tr>
            <td>int</td>
            <td>0</td>
        </tr>
        <tr>
            <td>long</td>
            <td>0L</td>
        </tr>
        <tr>
            <td>float</td>
            <td>0.0f</td>
        </tr>
        <tr>
            <td>double</td>
            <td>0.0d</td>
        </tr>
    </table>

    Значения по умолчанию гарантируются Java только в том случае, если переменная используется <i>как член класса.</i>
    Тем самым обеспечивается обязательная инициализация элементарных типов(что не делается в C++), которая уменьшает
    вероятность ошибок. Однако значение по умолчанию может быть неверным или даже недопустимым для вашей программы.
    Переменные всегда лучше инициализировать явно.

    Такая гарантия не относится к <i>локальным переменным</i>, которые не являются полями класса. Допустим, в определении
    метода встречается объявление переменной

    <pre>
        int x;
    </pre>

    Переменной x будет присвоено случайное значение (как в C и C++); она не будет автоматически инициализирована нулём.
    Если же вы забудете это сделать, в Java существует очевидное преимущество в сравнении с C++: компилятор выдаёт
    ошибку, в которой указано, что переменная не была инициализирована. (Многие компиляторы C++ предупреждают о таких
    переменных, но в Java это считается ошибкой.)
</p>

<h2>Методы, аргументы и возвращаемые значения</h2>
<p>
    Во многих языках (таких как C и C++) для обозначения именованной подпрограммы употребляется термин <i>функция</i>.
    В Java чаще предпочитают термин <i>метод</i>, как бы подразумевающий "способ что-то сделать". Если вам хочется,
    вы можете продолжать пользоваться термином "функция". Разница только в написании, но в дальнейшем в книге будет
    употребляться преимущественно термин "метод".

    Методы в Java определяют сообщения, принимаемые объектом. Осовные части метода - имя, аргументы, возвращаемый тип
    и тело. Вот примерная форма:

    <pre>
        возвращаемыйТип ИмяМетода( /* список аргументов */ ) {

        }
    </pre>

    Возвращаемый тип - это тип объекта, "выдаваемого" методом после его вызова. Список агрументов определяет типы и
    имена для информации, которую вы хотите передать в метод. Имя метода и его список аргументов (объединяемые термином
    <i>сигнатура</i>) обеспечивают однозначную идентификацию метода.

    Методы в Java создаются только как части класса. Метод может вызываться только для объекта
    <sup>
        1
        <span hidden>
            Статические методы, о которых вы узнаете немного позже, вызываются для <i>класса</i>, а не для объекта.
        </span>
    </sup>,
    и этот объект должен обладать возможностью произвести такой вызов. Если вы попытаетесь вызвать для объекта
    несуществующий метод, то получите ошибку копиляции. Вызов метода осуществляется следующим образом: сначала
    записывается имя объекта, за ним точка, за ней следуют имя метода и его список аргументов:

    <pre>
        имяОбъекта.имяМетода(арг1, арг2, арг3)
    </pre>

    Например, представьте, что у вас есть метод f(), вызываемый без аргументов, который возвращает значение типа int.
    Если у вас имеется в наличии объект a, для которого может быть вызван метод f(), в вашей власти использовать
    следующую конструкцию:

    <pre>
        int x = a.f();
    </pre>

    Тип возвращамемого значения должен быть совместим с типом x.

    Такое действие вызова метода часто называется <i>посылкой сообщения объекту</i>.

    В примере выше сообщением является вызов f(), а объектом - a. Объектно-ориентированное программирование нередко
    характеризуется обобщающей фомулой "помылка сообщений объектам".
</p>

<h2>Список аргументов</h2>
<p>
    Список аргументов определяет, какая информация передаётся методу. Как легко догадаться, эта информация - как и все
    в Java - воплощается в форме объектов, поэтому в списке должны быть указаны как типы передаваемых объектов, так и их
    имена. Как и в любой другой ситуации в Java, где мы вроде бы работает с объектами, на самом деле используются
    ссылки.
    <sup>
        2
        <span>
            За исключением уже упомянутых "специальных" типов данных: boolean, byte, short, char, int, float, long,
            double. Впрочем, в основном вы будете передавать объекты, а значит, ссылки на них.
        </span>
    </sup>


    Впрочем, тип ссылки должен соответствовать типу передаваемых данных. Если предполагается, что аргумент является
    строкой (то есть объектом String), вы должны передать именно строку, или ожидайте сообщения об ошибке.

    Рассмотрим метод, получающий в качестве аргумента строку (String). Следующее определение должно размещаться внутри
    определения класса, для которого создаётся метод:

    <pre>
        int storage(String s) {
            return s.length() * 2;
        }
    </pre>

    Метод указывает, сколько байтов потребуется для хранения данных определённой строки. (Строки состоят из символов
    char, размер которых - 16 бит, или 2 байта; это сделано для поддержки набора символов Unicode.) Аргумент имеет
    тип String и называется s. Получив объект s, метод может работать с ним точно так же, как и с любым бругим объектом
    (то есть посылать ему сообщения). В данном случае вызывается метод length(), один из методов класса String;
    он возвращает количество символов в строке.

    Также обратите внимание на ключевое слово return, выполняющее два действия. Во-первых, оно означает: "выйти
    из метода, всё сделано". Во-вторых, если метод возвращает значение, это значение указывается сразу же за
    командой return. В нашем случае возвращаемое значение - это результат вычисления

    <pre>
        s.length() * 2.
    </pre>

    Метод может возвращать любой тип, но, если вы не хотите пользоваться этой возможностью, следует указать, что метод
    возвращает void. Ниже приведено несколько примеров:

    <pre>
        boolean flag() { return true; }
        float naturalLogBase() { return 2.718; }
        void nothing() { return; }
        void nothing2() {}
    </pre>

    Когда выходным типом является void, ключевое слово return нужно лишь для завершения метода, поэтому при достижении
    конца метода его присутствие необязательно. Вы можете покинуть метод в любой момент, но если при этом указывается
    возвращаемый тип, отличный от void, то компилятор заставит вас (сообщениями об ошибках) вернуть подходящий тип
    независимо от того, в каком месте было прервано выполнение.

    К этому моменту может сложиться впечатление, что программа - это просто "свалка" объектов со своими методами,
    которые принимают другие объекты в качестве аргументов и посылают им сообщения. По большому счёту так оно и есть,
    но в следующей главе вы узнаете, как производить кропотливую низкоуровневую работу с принятием решений внутри
    метода. В этой главе достаточно рассмторения на уровне посылки сообщений.
</p>

<h2>Создание программы на Java</h2>
<p>
    Есть ещё несколько вопросов, которые необходимо поднять перед созданием первой программы на Java.
</p>

<h2>Видимость имён</h2>
<p>
    Проблема управления именами присуща любому языку программирования.

    Если имя используется в одном из модулей программы и оно случайно совпало с именем в другом модуле у другого
    программиста, то как отличить одно имя от другого и предотвратить их конфликт? В C это определённо является
    проблемой, потому что программа с трудом поддаётся контролю в условиях "моря" имён. Классы C++ (на которых основаны
    классы Java) скрывают функции внутри классов, поэтому их имена не пересекаются с именами функций других классов.
    Однако в C++ дозволяется использование глобальных данных и глобальных функций, соответственно, конфликты полностью
    не исключены. Для решения означенной проблемы в С++ введены <i>пространства имён</i> (namespaces), которые
    используют дополнительные ключевые слова.

    В языке Java для решения этой проблемы было использовано свежее решение. Для создания уникальных имён библиотек
    разработчики Java предлагают использовать доменное имя, записанное "наоборот", так как эти имена всегда уникальны.

    Моё доменное имя -
    <code>
        MindView.net, и утилиты моей программной библиотеки могли бы называться <code>net.mindview.utility.foibles.</code>
        За перевёрнутым доменным именем следует перечень каталогов, разделённых точками.
    </code>

    В версиях Java 1.0 и 1.1 доменные суффиксы com, edu, org, net по умолчанию записывались заглавными буквами, таким
    образом, имя библиотеки выглядело так:

    <code>
        NET.mindview.utility.foibles.
    </code>

    В процессе разработки Java 2 было обнаружено, что принятый подход создаёт проблемы, и с тех пор имя записывается
    строчными буквами.

    Такой механизм значит, все ваши файлы автоматически располагаются в своих собственных пространствах имён, и каждый
    класс в файле должен иметь уникальный идентификатор. Язык сам предотвращает конфликты имён.
</p>

<h2>Использование внешних компонентов</h2>
<p>
    Когда вам понадобится использовать уже определённый класс в вашей программе, компилятор должен знать, как этот
    класс обнаружить. Конечно, класс может уже находиться в том же самом исходном файле, откуда он вызывается.
    В таком случае вы просто его используете - даже если определение класса следует где-то дальше в файле
    (В Java не существует проблемы "опережающих ссылок".)

    Но что, если класс находится в каком-то внешнем файле? Казалось бы, компилятор должен запросто найти его, но здесь
    существует проблема. Представьте, что вам необходим класс с неким именем, для которого имеется более одного
    определения (вероятно, отличающихся друг от друга). Или, что ещё хуже, представьте, что вы пишите программу и при
    её создании в библиотеку добавляется новый класс, конфликтующий с именем уже существующего класса.

    Для решения проблемы вам необходимо устранить все возможные неоднозначности. Задача решается при помощи ключевого
    слова import, которое говорит копилятору Java, какие точно классы нужны. Слово import приказывает компилятору
    загрузить <i>пакет</i> (package), представляющий собой библиотеку
</p>
</body>
</html>
