<!DOCTYPE html>
<html>
<head lang="ru">
    <meta charset="UTF-8">
    <title></title>
    <style>

    </style>
</head>
<body>
<h1>Всё является объектом</h1>

<p>
    Хотя язык Java основан на C++, он является более "чистокровным" объектно-ориентированным языком.

    Как C++, так и Java относятся к семейству смешанных языков, но дял создателей Java эта неоднородность
    была не так важна, если сравнивать с C++. Смешанный язык позволяет использовать несколько стилей
    программирования; причиной смешанной природы C++ стало желание сохранить совместимость с языком C.
    Так как язык C++ является надстройкой языка C, он включает в себя много нежелательных характеристик своего
    предшественника, что приводит к излишнему усложнению некоторых аспектов этого языка.

    Язык программирования Java подразумевает, что вы занимаетесь только объектно-ориентированным программированием.
    А это значит, что прежде, чем начать с ним работать, нужно "переключится" на понятия объектно-ориентированного
    мира (если вы уже этого не сделали).

    Выгода от этого начального усилия - возможность программировать на языке, который по простоте изучения и
    пользования превосходит все остальные языки ООП. В этой главе мы рассмотрим основные Java-программы и узнаем,
    что в Java (почти) всё является объектом.
</p>

<h2>Для работы с объектами используются ссылки</h2>
<p>
    Каждый язык программирования имеет свои манипуляции данными. Иногда программисту приходится быть постоянно в
    курсе, какая именно манимуляция производится в программе. Вы работаете с самим объектом или же с каким-то
    видом его косвенного представления (указатель в C или в C++), требующим особого синтаксиса?

    Все эти различия упрощены в Java. Вы обращаетесь со всем как с объектом, и поэтому повсюду используется единый
    последовательный синтаксис. Хотя вы обращаетесь со всем как с объектом, идентификатор, которым вы манипулируете,
    на самом деле представляет собой ссылку на объект<sup>1</sup>. Представьте себе телевизор (объект) с пультом
    дистанционного управления (ссылка). Во время владения этой ссылкой у вас имеется связь с телевизором,
    но при переключении канала или уменьшении громкости вы распоряжаетесь ссылкой, которая в свою очередь,
    манипулирует объектов. А если вам захочется перейти в другое место комнаты, все еще управляя телевизором, вы
    берёте с собой "ссылку", а не сам телевизор.

    Также пульт может существовать сам по себе, без телевизора. Таким образом, сам факт наличия ссылки еще не
    означает наличия присоединенного к ней объекта. Например, для хранения слова или предложения создается ссылка

    <pre>
        String:
            String s;
    </pre>

    Однако здесь определяется <i>только</i> ссылка, но не объект. Если вы решите послать сообщение s, произойдёт
    ошибка, потому что ссылка s на самом деле ни к чему не присоединена (телевизора нет). Значит, безопаснее всегда
    инициализировать ссылку при её создании:

    <pre>
        String s = "asdf";
    </pre>

    В данном примере используется специальная возможность Java: инициализация строк текстом в кавычках. Обычно вы
    будете использовать более общий способ инициализации объектов.
</p>

<h2>Все объекты дожны создаваться явно</h2>
<p>
    Когда вы определяете ссылку, желательно присоеденить её к новому объекту. В основном это делается при помощи
    ключевого слова new. Фактически оно означает: "Создайте мне новый объект". В предыдущем примере можно написать:

    <pre>
        String s = new String("asdf");
    </pre>

    Это не только значит "предоставьте мне новый объект String", но также казывает, как создать строку посредством
    передачи начального набора символов.

    Конечно, кроме String, в Java имеется множество готовых типов. Важнее то, что вы можете создавать свои
    собственные типы. Вообще говоря, именно создание новых типов станет вашим основным занятием при программировании
    на Java, и именно его мы будет рассматривать в книге.
</p>
<h2>Где хранятся данные</h2>
<p>
    Полезно отчётливо представлять, что происходит во время работы программы - и в частности, как данные
    размещаются в памяти. Существует пять разных мест для хранения данных:

    <ol>
        <li>
            <strong>Регистры.</strong> Это самое быстрое хранилище, потому что данные хранятся прямо внутри
            процессора. Однако количество регистров жестко ограничено, поэтому регистры используются компилятором
            по мере необходимости. У вас нет прямого доступа к регистрам, вы не сможете найти и малейших следов их
            поддержки в языке. (С другой стороны, языки C и C++ позволяют порекомендовать компилятору данные
            в регистрах.)
        </li>
        <li>
            <strong>Стек.</strong> Эта область хранения данных находится в общей оперативной памяти (RAM), но
            процессор предоставляет прямой доступ к ней с использованием <i>указателя стека.</i> Указатель стека
            перемещается вниз для выделения памяти или вверх для её освобождения. Это чрезвычайно быстрый и
            эффективный способ размещения данных, по скорости уступающий только регистрам. Во время обработки
            программы компилятор Java должен знать жизненный цикл данных, размещаемых в стеке. Это ограничение
            уменьшает гибкость ваших программ, поэтому, хотя некоторые данные Java хранятся в стеке (особенно ссылки
            на объекты), сами объекты Java не помещаются в стек.
        </li>
        <li>
            <strong>Куча.</strong> Пул памяти общего назначения (находится также в RAM), в котором размещаются все
            объекты Java. Преимущество кучи состоит в том, что компилятору не обязательно знать, как долго
            просуществуют находящиеся там объекты. Таким образом, работа с кучей даёт значительное преимущество
            в гибкости. Когда вам нужно создать объект, вы пишете код с использованием new, и память выделяется из
            кучи во время выполнения программы. Конечно, за гибкость приходится расплачиваться: выделение памяти
            из кучи занимает больше времени, чем в стеке (даже если вы <i>могли</i> явно создавать объекты в стеке,
            как в C++).
        </li>
        <li>
            <strong>Постоянная память.</strong> Значения констант часто встраиваются прямо в код программы,
            так как они неизменны. Иногда такие данные могут размещать в постоянной памяти (ROM), если речь идёт о
            "встроенных" системах.
        </li>
        <li>
            <strong>Не-оперативная память.</strong> Если данные располагаются вне программы, они могут существовать
            и тогда, когда она ен выполняется. Два основных примера: <i>потоковые объекты</i> (streamed objects),
            в которых объекты представлены в виде потока байтов, обычно используются для посылки на другие машины,
            и <i>долгоживущие</i> (persistent) <i>объекты</i>, которые запоминаются на диске и сохраняют своё
            состояние даже после окончания работы программы. Особенностью этих видов хранения данных является
            возможность перевода объектов в нечто, что может быть сохранено на другом носителе информации,
            а потом восстановлено в виде обычного объекта, хранящегося в оперативной памяти. В Java организована
            поддержка <i>легковесного</i> (lightweight) <i>сохранения состояния,</i> а такие механизмы, как JDBC и
            Hibernate, предоставляют более совершенную поддержку сохранения и выборки информации об объектах из баз
            данных.
        </li>
    </ol>
</p>
<!--50-->

<h2>Особый случай: примитивные типы</h2>
<p>
    Одна из групп типов, часто применяемых при программировании, требует особого обращения. Их можно назвать
    "примитивными" типами (табл. 2.1). Причина для особого обращения состоит в том, что создание объекта с помощью
    new - особенно маленькой простой переменной - недостаточно эффективно, так как new помещает объекты в кучу.
    В таких случаях Java следует примеру языков C и C++. То есть вместо создания переменной с помощью new создается
    "автоматическая" переменная, <i>не являющаяся ссылкой.</i> Переменная напрямую хранит значение и располагается в
    стеке, так что операции с ней гораздо производительнее.

    В Java размеры всех примитивных типов жёстко фиксированы. Они не меняются с переходом на иную машинную
    архитектуру, как это происходит во многих других языках. Незыблемость размера - одна из причин улучшенной
    переносимости Java-программ.

    <h3><strong>Таблица 2.1.</strong> Примитивные типы</h3>
    <table>

            <thead>
                <th>Примитивный тип</th>
                <th>Размер, бит</th>
                <th>Минимум</th>
                <th>Максимум</th>
                <th>Тип упаковки</th>
            </thead>


        <tr>
            <td>boolean (логические значения)</td>
            <td>-</td>
            <td>-</td>
            <td>-</td>
            <td>Boolean</td>
        </tr>
    </table>

    Все числовые значения являются знаковыми, так что не ищите слова unsigned.

    Размер типа boolean явно не определяется; указывается лишь то, что этот тип может принимать значения true и false.

    "Классы-обёртки" позволяют создать в куче не-примитивный объект для представления примитивного типа. Например:

    <pre>
        char c = 'x'.
        Character ch = new Character(c).
    </pre>
</p>
<!--51-->

<p>
    Также можно использовать такой синтаксис:

    <pre>
        Character ch = new Character('x');
    </pre>

    Механизм <i>автоматической упаковки</i> Java SE5 автоматически преобразует примитивный тип в объектную "обёртку":

    <pre>
        Character ch = 'x';
    </pre>

    и обратно

    <pre>
        char c = ch;
    </pre>

    Причины создания подобных конструкий будут объяснены в последующих главах.
</p>

<h2>Числа повышенной точности</h2>
<p>
    В Java существует два класса для проведения арифметических операций повышенной точности:
    <strong>BigInteger </strong>и <strong>BigDecimal</strong>.
    Хотя эти классы примерно подходят под определение "класс-обёрток", ни один из них не имеет аналога среди
    примитивных типов.

    Оба класса содержатметоды, производящие операции, аналогичные тем, что проводятся над примитивными типами. Иначе
    говоря, с классами <strong>BigInteger</strong> и <strong>BigDecimal</strong> можно делать то же, что с
    <strong>int</strong> или <stong>float</stong>, просто для этого используются вызовы методов, а не встроенные
    операции. Также из-за использования увеличенного объема данных операции занимают больше времени. Приходится
    жертвовать скоростью ради точности.

    Класс <strong>BigInteger</strong> поддерживает целые числа произвольной точности. Это значит, что вы можете
    использовать целочисленные значения любой величины без потери данных во время операций.

    Класс <strong>BigDecimal</strong> представляет числа с фиксированной запятой произвольной точности; например,
    они могут применяться для финансовых вычислений.

    За подробностями о конструкторах и методах этих классов обращайтесь в документацию JDK.
</p>

<h2>Массивы в Java</h2>
<p>
    Фактически все языки программирования поддерживают массивы. Использование массивов в C и C++ небезопасно, потому
    что массивы в этих языках представляют собой обычно блоки памяти. Если программа попытается получить доступ к
    массиву за пределами его блока памяти или использовать память без предварительной инициализации (типичные
    ошибки при программировании), последствия могут быть непредсказуемы.

    Одной из основных целей Java является безопасность, поэтому многие проблемы, досаждавшие программистам на C и C++,
    не существуют в Java. Массив в Java гарантированно инициализируется, к нему невозможен доступ за пределами его
    границ. Проверка границ массива обходится относительно дорого, как и проверка индекса во время выполнения, но
    предполагается, что повышение безопасности и подъём производительности стоят того (к тому же Java иногда
    может оптимизировать эти операции).
</p>
<!--52-->

<p>
    При объявлении массива объектов на самом деле создается массив ссылок, и каждая из этих ссылок автоматически
    инициализируется специальным значением, представленным ключевым словом <strong>null.</strong> Оно означает,
    что ссылка на самом деле не указывается на объект. Вам необходимо присоединять объект к каждой ссылке перед
    тем, как её использовать, или при попытке обращения по ссылке null во время исполнения программы произойдёт ошибка.
    Таким образом, типичные ошибки при работа с массивами в Java предотвращаются заблаговременно.

    Также можно создавать массивы простейших типов. И снова компилятор гарантирует инициализацю - выделенная для
    нового массива память заполняется нулями.

    Массивы будут подробнее описаны в последующих главах.
</p>

<h2>Объекты никогда не приходится удалять</h2>
<p>
    В большинстве языков программирования концепция жизненного цикла переменной требует относительно заметных
    усилий со стороны программиста. Сколько "живёт" переменная? Если её необходимо удалить, когда это следует делать?
    Путаница со сроками существования переменных может привести ко многим ошибкам, и этот раздел показывает, насколько
    Java упрощает решение затронутого вопроса, выполняя всю работу по удалению за вас.
</p>

<h2>Ограничение области действия</h2>
<p>
    В большинстве процедурных языков существует понятие <i>области действия</i> (scope). Область действия
    определяет как видимость, так и срок жизни имён, определенных внутри неё. В C, C++ и Java область действия
    устанавливается положением фигурных скобок {}. Например:

    <pre>
    {
        int x = 12;
        // доступно только x
        {
            int q = 96;
            // доступны как x, так и q
        }
        // доступно только x
        // q находится "за пределами видимости"
    }
    </pre>

    Переменная, определенная внутри области действия, доступна только в пределах этой области.

    Весь текст после символов // и до конца строки является комментарием.

    Отступы упрощают чтение программы на Java. Так как Java относится к языкам со свободным форматом,
    дополнительные пробелы, табуляция и переводы строк не влияют на результирующую программу.

    Учтите, что следующая конструкция <i>не разрешена</i>, хотя в C и C++ она возможна:
</p>
<!--53-->

<p>
    <pre>
        {
            int x = 12;
            {
                int x = 96; // неверно
            }
        }
    </pre>

    Компилятор объявит, что переменная x уже была определена. Таким образом, возможность языков C и C++ "прятать" переменные
    во внешней области действия не поддерживается. Создатели Java посчитали, что она приводит к излишнему усложнению программ.
</p>

<h2>Область действия объектов</h2>
<p>
    Объекты Java имеют другое время жизни в сравнеи с примитивами. Объект, созданный оператором Java <strong>new</strong>,
    будет доступен вплоть до конца области действия. Если вы напишите:

    <pre>
        {
            String s = new String("строка");
        } // конец области действия
    </pre>

    то ссылка s исчезнет в конце области действия. Однако объект String, на который указывала s, всё ещё будет занимать
    память. В показанном фрагменте кода невозможно получить доступ к объекту, потому что единственная ссылка вышла
    за пределы видимости. В следующих главах вы узнаете, как передаются ссылки на объекты и как их можно копировать во
    время работы программы.

    Благодаря тому, что объекты, созданные <strong>new</strong>, существуют ровно столько, сколько вам нужно, в Java
    исчезает целый пласт проблем, присущих C++. В C++ приходится не только следить за тем, чтобы объекты продолжали
    существовать на протяжении своего жизненного цикла, но и удалять объекты после завершения работы с ними.

    Возникает интересный вопрос. Если в Java объекты остаются в памяти, что же мешает им постепенно занять всю память
    и остановить выполнение программы? Именно это произошло бы в данном случае в C++. Однако в Java существует
    <i>сборщик мусора</i> (garbage collector), который наблюдает за объектами, созданными оператором <strong>new</strong>,
    и определяет, на какие из них больше нет ссылок. Тогда он освобождает память от этих объектов, которая становится
    доступной для дальнейшего использования. Таким образом, вам никогда не придётся "очищать" память вручную. Вы просто
    создаёте объекты, и как только надобность в них отпадёт, эти объекты исчезают сами по себе. При таком подходе
    исчезает целый класс проблем программирования: так называется "утечки памяти", когда программист забывает
    освобождать занятую память.
</p>

<h2>Создание новы типов данных</h2>
<p>
    Если всё является объектом, что определяет строение и поведение класса объектов? Другими словами, как устанавливается
    <i>тип</i> объекта? Наверное, для этой цели можно было бы использовать ключевое слово <strong>type</strong> ("тип");
    это было бы вполне разумно. Впрочем, с давних времён повелось, что большинство объектно-ориентированных языков
    использовали ключевое слово <strong>class</strong> в смысле "Я собираюсь описать новый тип объектов". За ключевым
    словом <strong>class</strong> следует имя нового типа. Например:

    <pre>
        class ATypeName { /* Тело класса */ }
    </pre>

    Эта конструкция вводит новый тип, и поэтому вы можете теперь создавать объект этого типа ключевым словом new:

    <pre>
        ATypeName a = new ATypeName();
    </pre>

    Впрочем, объекту нельзя "приказать" что-то сделать ( то есть послать ему необходимые сообщения) до тех пор,
    пока для него не будут определены методы.
</p>

<h2>Поля и методы</h2>
<p>
    При определении класса (строго говоря, вся ваша работа на Java сводится к определению классов, созданию объектов
    этих классов и посылке сообщений этим объектам) в него можно включить две разновидности элементов: <i>поля</i>
    (fields)(иногда называемые переменными класса) и <i>методы</i> (methods) (еще называемые функциями класса). Поле
    представляет собой объект любого типа, с которым можно работать по ссылке, или объект примитивного типа. Если
    используется ссылка, её необходимо инициализировать, чтобы связать с реальным объектом (ключевым словом new, как было
    показано ранее).

    Каждый объект использует собственный блок памяти для своих полей данных; совместное использование обычный полей
    разными объектами класса невозможно. Пример класса с полями:

    <pre>
        class DataOnly {
            int i;
            double d;
            boolean b;
        }
    </pre>

    Такой класс ничего не <i>делает</i>, кроме хранения данных, но вы можете создать объект этого класса:

    <pre>
        DataOnly data = new DataOnly();
    </pre>

    Полям класса можно присваивать значения, но для начала необходимо узнать, как обращаться к членам объекта. Для
    этого сначала указывается имя ссылки на объект, затем следует точка, а далее - имя члена, принадлежащего объекту:

    <pre>
        ссылка.член
    </pre>

    Например:

    <pre>
        data i = 47;
        data.d = 1.1;
        data.b = false;
    </pre>

    Также ваш объект может содержать другие объекты, данные которых вы хотели бы изменить. Для этого просто продолжите
    "цепочку из точек". Например:

    <pre>
        myPlane.leftTank.capacity = 100;
    </pre>

    Класс DataOnly не способен ни на что, кроме хранения данных, так как в нём отсутствуют методы. Чтобы понять, как
    они работают, необходимо разобраться, что такое <i>аргументы</i> и <i>возвращаемые значения</i>. Вскоре мы вернёмся
    к этой теме.
</p>

<h2>Значения по умолчанию для полей примитивных типов</h2>
<p>
    Если поле данных относится к примитивному типу, ему гарантировано присваивается значение по умолчанию, даже если
    оно не было инициализировано явно (табл. 2.2).

    <h3><strong>Таблица 2.2.</strong> Значения по умолчанию для полей примитивных типов</h3>
    <table>
        <thead>
            <td><strong>Примитивный тип</strong></td>
            <td><strong>Значение по умолчанию</strong></td>
        </thead>
        <tr>
            <td>boolean</td>
            <td>false</td>
        </tr>
        <tr>
            <td>char</td>
            <td>`\u0000` (null)</td>
        </tr>
        <tr>
            <td>byte</td>
            <td>(byte)0</td>
        </tr>
        <tr>
            <td>short</td>
            <td>(short)0</td>
        </tr>
        <tr>
            <td>int</td>
            <td>0</td>
        </tr>
        <tr>
            <td>long</td>
            <td>0L</td>
        </tr>
        <tr>
            <td>float</td>
            <td>0.0f</td>
        </tr>
        <tr>
            <td>double</td>
            <td>0.0d</td>
        </tr>
    </table>

    Значения по умолчанию гарантируются Java только в том случае, если переменная используется <i>как член класса.</i>
    Тем самым обеспечивается обязательная инициализация элементарных типов(что не делается в C++), которая уменьшает
    вероятность ошибок. Однако значение по умолчанию может быть неверным или даже недопустимым для вашей программы.
    Переменные всегда лучше инициализировать явно.

    Такая гарантия не относится к <i>локальным переменным</i>, которые не являются полями класса. Допустим, в определении
    метода встречается объявление переменной

    <pre>
        int x;
    </pre>

    Переменной x будет присвоено случайное значение (как в C и C++); она не будет автоматически инициализирована нулём.
    Если же вы забудете это сделать, в Java существует очевидное преимущество в сравнении с C++: компилятор выдаёт
    ошибку, в которой указано, что переменная не была инициализирована. (Многие компиляторы C++ предупреждают о таких
    переменных, но в Java это считается ошибкой.)
</p>

<h2>Методы, аргументы и возвращаемые значения</h2>
<p>
    Во многих языках (таких как C и C++) для обозначения именованной подпрограммы употребляется термин <i>функция</i>.
    В Java чаще предпочитают термин <i>метод</i>, как бы подразумевающий "способ что-то сделать". Если вам хочется,
    вы можете продолжать пользоваться термином "функция". Разница только в написании, но в дальнейшем в книге будет
    употребляться преимущественно термин "метод".

    Методы в Java определяют сообщения, принимаемые объектом. Осовные части метода - имя, аргументы, возвращаемый тип
    и тело. Вот примерная форма:

    <pre>
        возвращаемыйТип ИмяМетода( /* список аргументов */ ) {

        }
    </pre>

    Возвращаемый тип - это тип объекта, "выдаваемого" методом после его вызова. Список агрументов определяет типы и
    имена для информации, которую вы хотите передать в метод. Имя метода и его список аргументов (объединяемые термином
    <i>сигнатура</i>) обеспечивают однозначную идентификацию метода.

    Методы в Java создаются только как части класса. Метод может вызываться только для объекта
    <sup>
        1
        <span hidden>
            Статические методы, о которых вы узнаете немного позже, вызываются для <i>класса</i>, а не для объекта.
        </span>
    </sup>,
    и этот объект должен обладать возможностью произвести такой вызов. Если вы попытаетесь вызвать для объекта
    несуществующий метод, то получите ошибку копиляции. Вызов метода осуществляется следующим образом: сначала
    записывается имя объекта, за ним точка, за ней следуют имя метода и его список аргументов:

    <pre>
        имяОбъекта.имяМетода(арг1, арг2, арг3)
    </pre>

    Например, представьте, что у вас есть метод f(), вызываемый без аргументов, который возвращает значение типа int.
    Если у вас имеется в наличии объект a, для которого может быть вызван метод f(), в вашей власти использовать
    следующую конструкцию:

    <pre>
        int x = a.f();
    </pre>

    Тип возвращамемого значения должен быть совместим с типом x.

    Такое действие вызова метода часто называется <i>посылкой сообщения объекту</i>.

    В примере выше сообщением является вызов f(), а объектом - a. Объектно-ориентированное программирование нередко
    характеризуется обобщающей фомулой "помылка сообщений объектам".
</p>

<h2>Список аргументов</h2>
<p>
    Список аргументов определяет, какая информация передаётся методу. Как легко догадаться, эта информация - как и все
    в Java - воплощается в форме объектов, поэтому в списке должны быть указаны как типы передаваемых объектов, так и их
    имена. Как и в любой другой ситуации в Java, где мы вроде бы работает с объектами, на самом деле используются
    ссылки.
    <sup>
        2
        <span>
            За исключением уже упомянутых "специальных" типов данных: boolean, byte, short, char, int, float, long,
            double. Впрочем, в основном вы будете передавать объекты, а значит, ссылки на них.
        </span>
    </sup>


    Впрочем, тип ссылки должен соответствовать типу передаваемых данных. Если предполагается, что аргумент является
    строкой (то есть объектом String), вы должны передать именно строку, или ожидайте сообщения об ошибке.

    Рассмотрим метод, получающий в качестве аргумента строку (String). Следующее определение должно размещаться внутри
    определения класса, для которого создаётся метод:

    <pre>
        int storage(String s) {
            return s.length() * 2;
        }
    </pre>

    Метод указывает, сколько байтов потребуется для хранения данных определённой строки. (Строки состоят из символов
    char, размер которых - 16 бит, или 2 байта; это сделано для поддержки набора символов Unicode.) Аргумент имеет
    тип String и называется s. Получив объект s, метод может работать с ним точно так же, как и с любым бругим объектом
    (то есть посылать ему сообщения). В данном случае вызывается метод length(), один из методов класса String;
    он возвращает количество символов в строке.

    Также обратите внимание на ключевое слово return, выполняющее два действия. Во-первых, оно означает: "выйти
    из метода, всё сделано". Во-вторых, если метод возвращает значение, это значение указывается сразу же за
    командой return. В нашем случае возвращаемое значение - это результат вычисления

    <pre>
        s.length() * 2.
    </pre>

    Метод может возвращать любой тип, но, если вы не хотите пользоваться этой возможностью, следует указать, что метод
    возвращает void. Ниже приведено несколько примеров:

    <pre>
        boolean flag() { return true; }
        float naturalLogBase() { return 2.718; }
        void nothing() { return; }
        void nothing2() {}
    </pre>

    Когда выходным типом является void, ключевое слово return нужно лишь для завершения метода, поэтому при достижении
    конца метода его присутствие необязательно. Вы можете покинуть метод в любой момент, но если при этом указывается
    возвращаемый тип, отличный от void, то компилятор заставит вас (сообщениями об ошибках) вернуть подходящий тип
    независимо от того, в каком месте было прервано выполнение.

    К этому моменту может сложиться впечатление, что программа - это просто "свалка" объектов со своими методами,
    которые принимают другие объекты в качестве аргументов и посылают им сообщения. По большому счёту так оно и есть,
    но в следующей главе вы узнаете, как производить кропотливую низкоуровневую работу с принятием решений внутри
    метода. В этой главе достаточно рассмторения на уровне посылки сообщений.
</p>

<h2>Создание программы на Java</h2>
<p>
    Есть ещё несколько вопросов, которые необходимо поднять перед созданием первой программы на Java.
</p>

<h2>Видимость имён</h2>
<p>
    Проблема управления именами присуща любому языку программирования.

    Если имя используется в одном из модулей программы и оно случайно совпало с именем в другом модуле у другого
    программиста, то как отличить одно имя от другого и предотвратить их конфликт? В C это определённо является
    проблемой, потому что программа с трудом поддаётся контролю в условиях "моря" имён. Классы C++ (на которых основаны
    классы Java) скрывают функции внутри классов, поэтому их имена не пересекаются с именами функций других классов.
    Однако в C++ дозволяется использование глобальных данных и глобальных функций, соответственно, конфликты полностью
    не исключены. Для решения означенной проблемы в С++ введены <i>пространства имён</i> (namespaces), которые
    используют дополнительные ключевые слова.

    В языке Java для решения этой проблемы было использовано свежее решение. Для создания уникальных имён библиотек
    разработчики Java предлагают использовать доменное имя, записанное "наоборот", так как эти имена всегда уникальны.

    Моё доменное имя -
    <code>
        MindView.net, и утилиты моей программной библиотеки могли бы называться <code>net.mindview.utility.foibles.</code>
        За перевёрнутым доменным именем следует перечень каталогов, разделённых точками.
    </code>

    В версиях Java 1.0 и 1.1 доменные суффиксы com, edu, org, net по умолчанию записывались заглавными буквами, таким
    образом, имя библиотеки выглядело так:

    <code>
        NET.mindview.utility.foibles.
    </code>

    В процессе разработки Java 2 было обнаружено, что принятый подход создаёт проблемы, и с тех пор имя записывается
    строчными буквами.

    Такой механизм значит, все ваши файлы автоматически располагаются в своих собственных пространствах имён, и каждый
    класс в файле должен иметь уникальный идентификатор. Язык сам предотвращает конфликты имён.
</p>

<h2>Использование внешних компонентов</h2>
<p>
    Когда вам понадобится использовать уже определённый класс в вашей программе, компилятор должен знать, как этот
    класс обнаружить. Конечно, класс может уже находиться в том же самом исходном файле, откуда он вызывается.
    В таком случае вы просто его используете - даже если определение класса следует где-то дальше в файле
    (В Java не существует проблемы "опережающих ссылок".)

    Но что, если класс находится в каком-то внешнем файле? Казалось бы, компилятор должен запросто найти его, но здесь
    существует проблема. Представьте, что вам необходим класс с неким именем, для которого имеется более одного
    определения (вероятно, отличающихся друг от друга). Или, что ещё хуже, представьте, что вы пишите программу и при
    её создании в библиотеку добавляется новый класс, конфликтующий с именем уже существующего класса.

    Для решения проблемы вам необходимо устранить все возможные неоднозначности. Задача решается при помощи ключевого
    слова import, которое говорит компилятору Java, какие точно классы нужны. Слово import приказывает компилятору
    загрузить <i>пакет</i> (package), представляющий собой библиотеку классов. (В других языках библиотека может
    состоять как из классов, так и из функций и данных, но в Java весь код принадлежит классам.)

    Большую часть времени вы будете работать с компонентами из стандартных библиотек Java, поставляющихся с компилятором.
    Для них не нужны длинные обращённые доменные имена; вы просто записываете

    <pre>
        import java.util ArrayList;
    </pre>

    чтобы сказать компилятору, что вы хотите использовать класс ArrayList. Впрочем, пакет util содержит множество
    классов, и вам могут понадобиться несколько из них. Чтобы избежать последовательного перечисления классов,
    используйте подстановочный символ *;

    <pre>
        import java util.*.
    </pre>

    Как правило, импортируется целый набор классов именно таким образом, а не выписывается каждый класс по отдельности.
</p>

<h2>Ключевое слово static</h2>
<p>
    Обычно при создании класса вы описываете, как объекты этого класса ведут себя и как они выглядят. Объект появляется
    только после того, как он будет создан ключевым словом new, и только начиная с этого момента для него выделяется
    память и появляется возможность вызова методов.

    Но есть две ситуации, в которых такой подход недостаточен. Первая - это когда некоторые данные должны храниться
    "в единственном числе" независимо от того, сколько было создано объектов класса. Вторая - когда вам потребуется метод,
    не привязанный ни к какому конкретному объекту класса (то есть метод, который можно вызвать даже при полном отсутствии
    объектов класса). Такой эффект достигается использованием ключевого слова static, делающего элемент класса
    <i>статическим</i>. Когда вы объявляете что-либо как static, это означает, что данные или метод не привязаны
    к определённому экземпляру этого класса. Поэтому, даже если вы никогда не создавали объектов класса, вы можете
    вызвать статический метод или получить доступ к статическим данным. С обычным объектом вам необходимо сначала
    создать его и использовать для вызова метода или доступа информации, так как нестатические данные и методы должны
    точно знать объект с которым работают.

    Некоторые объектно-ориентированные языки используют термины <i>данные уровня класса</i> и <i>методы уровня класса</i>,
    подразумевая, что данные и методы существуют только на уровне класса в целом, а не для отдельных объектов этого
    класса. Иногда эти термины встречаются в литературе по Java.

    Чтобы сделать данные или метод статическими, просто поместите ключевое слово static перед их определением.
    Например, следующий код создаёт статическое поле класса и инициализирует его:

    <pre>
        class StaticTest {
            static int = 47;
        }
    </pre>

    Теперь, даже при создании двух объектов <code>StaticTest</code>, для элемента <code>StaticTest.i</code> выделяется
    единственный блок памяти. Оба объекта совместно используют одно значение i. Пример:

    <pre>
        StaticTest st1 = new StaticTest();
        StaticTest st2 = new StaticTest();
    </pre>

    В данном примере как <code>st1.i</code>, так и <code>st2.i</code> имеют одинаковые значения, равные 47, потому что
    расположены они в одном блоке памяти.

    Существует два способа обратиться к статической переменной. Как было видно выше, вы можете указать её с помощью
    объекта, например st2.i. Также можно обратиться к ней прямо по имени класса (для нестатических членов класса такая
    возможность отсуствует):

    <pre>
        StaticTest i++.
    </pre>

    Оператор ++ увеличивает значение на единицу (инкремент). После выполнения этой команды значения st1.i и st2.i будут
    равны 48.

    Синтаксис с именем класса является предпочтительным, потому что он не только подчёркивает, что переменная описана как
    static, но и в некоторых случаях предоставляет компилятору больше возможностей для оптимизации.

    Та же логика верна и для статических методов. Вы можете обратиться к такому методу или через объект, как это делается
    для всех методов, или в специальном синтаксисе <code>имяКласса.метод().</code> Статические методы определяются по
    аналогии со статическими данными:

    <pre>
        class Incrementable {
            static void increment() { StaticTest i++; }
        }
    </pre>

    Нетрудно заметить, что метод increment() класса Incrementable увеличивает значение статического поля i. Метод
    можно вызвать стандартно, через объект:

    <pre>
        Incrementable sf = new Incrementable();
        sf increment();
    </pre>

    Или, поскольку increment() является статическим, можно вызвать его с прямым указанием класса:

    <pre>
        Incrementable.increment();
    </pre>

    Применительно к полям ключевое слово static радикально меняет способ определения данных: статические данные
    существуют на уровне класса, в то время как нестатические данные существуют на уровне объектов, но в отношении
    изменения не столь принципиальны. Одним из важных применений static является определение методов, которые могут
    вызываться без объектов. В частности, это абсолютно необходимо для метода <code>main()</code>, который представляет собой точку
    входа в приложение.
</p>

<h2>Наша первая программа на Java</h2>
<p>
    Наконец, долгожданная программа. Она запускается, выводит на экран строку, а затем текущую дату, используя стандартный
    класс Date из стандартной библиотеки Java:

    <pre>
	// HelloDate.java
	import java util.*;

	public class HelloDate {
		public static void main(String[] args) {
			System.out.println("Привет. сегодня: ");
			System.out.println(new Date());
		}
	}
    </pre>

	В начале каждого файла с программой должны находиться директивы import, в которых перечисляются все дополнительные
	классы, необходимые вашей программе. Обратите внимание на слово "дополнительные" - существует целая библиотека
	классов, присоединяющаяся автоматически к каждому файлу <code>Java: java.lang.</code> Запустите ваш браузер
	и просмотрите документацию фирмы Sun. Учтите, что документация не входит в комплект JDK; её необходимо загрузить
	отдельно. Взглянув на список пакетов, вы найдёте в нём различные библиотеки классов, составляющих эту библиотеку.
	Так как пакет <code>java.lang.</code> автоматически включается в каждую программу на Java, эти классы всегда
	доступны для использования. Класса Date в нём нет, а это значит, что для его использования придётся импортировать
	другую библиотеку. Если вы не знаете, в какой библиотеке находится нужный класс, или если вам понадобится увидеть
	все классы, выберите <strong>Tree</strong> (дерево классов) в документации. В нём можно обнаружить любой из
	доступных классов Java. Функция поиска текста в браузере поможет найти класс <strong>Date.</strong> Результат поиска
	показывает, что класс называется <code>java.util.Date</code>, то есть находится в библиотеке util, и для получения
	доступа к классу Date необходимо будет использовать директиву import для загрузки пакета <code>java.util.*.</code>

	Если вы вернётесь к началу, выберете пакет <code>java.lang</code>, а затем класс System, то увидите, что он имеет
	несколько полей. При выборе поля out обнаруживается, что оно представляет собой статический объект PrintStream. Так
	как поле описано с ключевым словом static, вам не понадобится создавать объекты. Действия, которые можно выполнять
	с объектом out, определяются его типом: PrintStream. Для удобства в описание этого типа включена гиперссылка, и,
	если щёлкнуть на ней, вы обнаружите список всех доступных методов. Этих методов довольно много, и они будут позже
	рассмотрены в книге. Сейчас нас интересует только метод println(), вызов которого фактически означает: "вывести то,
	что передано методу, на консоль и перейти на новую строку". Таким образом, в любую программу на Java можно включить
	вызов вида <code>System.out.println("что-то"), чтобы вывести сообщение на консоль.</code>

	Имя класса совпадает с именем файла. Когда вы создаёте отдельную программу, подобную этой, один из классов,
	описанных в файле, должен иметь совпадающее с ним название. (Если это условие нарушено, компилятор сообщит об ошибке.)
	Одноимённый класс должен содержать метод с именем main() со следующей сигнатурой и возвращаемым типом:

	<pre>
		public static void main(String[] args) {
	</pre>

	Ключевое слово public обозначает, что метод доступен для внешнего мира (об этом подробно рассказывает глава 5).
	Аргументом метода main() является массив строк. В данной программе массив args не используется, но компилятор Java
	настаивает на его присутствии, так как массив содержит параметры, переданные программе в командной строке.

	Строка, в которой распечатывается число, довольно интересна:

	<pre>
		System.out.println(new Date());
	</pre>

	Аргумент представляет собой объект Date, который создаётся лишь  затем, чтобы передать своё значение (автоматически
	преобразуемое в String) методу println(). Как только команда будет выполнена, объект Date становится ненужным,
	сборщик мусора заметит это, и в конце концов сам удалит его. Нам не нужно беспокоиться о его удалении самим.
</p>

<h2>Комментарии и встроенная документация</h2>
<p>
	В Java приняты два вида комментариев. Первый - традиционные комментарии в стиле C, также унаследованные языком C++.
	Такие комментарии начинаются с комбинации /* и распространяются иногда на множество строк, после чего заканчиваются
	символами */. Заметьте, что многие программисты начинают каждую новую строку таких комментариев символом *,
	соответственно, часто можно увидеть следующее:

	<pre>
	/* Это комментарий.
	* распространяющийся на
	* несколько строк
	*/
	</pre>

	Впрочем, все символы между /* и */ игнорируются, и с таким же успехом можно использовать запись

	<pre>
		/* Это комментарий, распространяющийся
		на несколько строк */
	</pre>

	Второй вид комментария пришёл из языка C++. Однострочный комментарий начинается с комбинации // и продолжается до
	конца строки. Такой стиль удобен и прост, поэтому широко используется на практике. Вам не приходится искать на
	клавиатуре сначала символ /, а затем * (вместо этого вы дважды нажимаете одну и ту же клавишу), и не нужно закрывать
	комментарий. Поэтому часто можно увидеть такие примеры:

	<pre>
		// это комментарий в одну строку
	</pre>
</p>

<h2>Документация в комментариях</h2>
<p>
	Пожалуй, основные проблемы с документированием кода связаны с его сопровождением. Если код и его документация
	существуют раздельно, корректировать описание программы при каждом её изменении становится задачей не из лёгких.
	Решение выглядит очень просто: совместить код и документацию. Проще всего объединить их в одном файле. Но для
	полноты картины понадобится специальный синтаксис комментариев, чтобы помечать документацию, и инструмент, который
	извлекал бы эти комментарии и оформлял их в подходящем виде. Именно это было сделано в Java.

	Инструмент для извлечения комментариев называется javadoc, он является частью пакета JDK. Некоторые возможности
	компилятора Java используются в нём для поиска пометок в комментариях, включенных в ваши программы. Он не только
	извлекает помеченную информацию, но также узнает имя класса или метода, к которому относится данный фрагмент
	документации. Таким образом, с минимум затраченных усилий можно создать вполне приличную сопроводительную
	документацию для вашей программы.

	Результатом работы программы javadoc является HTML-файл, который можно просмотреть в браузере. Таким образом,
	утилита javadoc позволяет создавать и поддерживать единый файл с исходным текстом и автоматически строить полезную
	документацию. В результате получается простой и практичный стандарт по созданию документации для всех библиотек
	Java.

	Вдобавок, вы можете дополнить javadoc своими собственными расширениями, называемыми <i>доклетами</i> (docklets),
	в которых можно проводить специальные операции над обрабатываемыми данными (например, выводить их в другом формате).

	Далее следует лишь краткое введение и обзор основных возможностей java-doc. Более подробное описание можно найти в
	документации JDK. Распаковав документацию, загляните в папку tooldocs (или перейдите по ссылке tooldocs).
</p>

<h2>Синтаксис</h2>
<p>
	Все команды javadoc находятся только внутри комментариев /**. Комментарии, как обычно, завершаются последовательно */.
	Комментарии, как обычно, завершаются последовательностью */. Существует два основных способа работы с javadoc:
	встраивание HTML-текста или использование разметки документации (тегов). <i>Самостоятельные теги документации</i> -
	это команды, которые начинаются символом @ и размещаются с новой строки комментария. (Начальный символ * игнорируется.)
	<i>Встроенные теги документации</i> могут располагаться в любом месте комментария javadoc, также начинается со
	знака @, но должны заключаться в фигурные скобки.

	Существует три вида документации в комментариях для разных элементов кода: класса, переменной и метода. Комментарий
	к классу записывается прямо перед его определением; комментарий к переменной размещается непосредственно перед её
	определением, а комментарий к методу тоже записывается прямо перед его определением. Простой пример:

	<pre>
	// object/Documentation1.java
	/** Комментарий к классу */
	public class Dcumentation1 {
		/** Комментарий к переменной */
		public int i;
		/** Комментарий к методу */
		public void f() {}
	} /// .~
	</pre>

	Заметьте, что javadoc обрабатывает документацию в комментариях только для членов класса с уровнем доступа
	public и protected. Комментарии для членов private и членов с доступом в пределах пакета игнорируются, и
	документация по ним не строится. Впрочем, флаг - private включает обработку и этих членов). Это вполне логично,
	поскольку только public - и protected - члены доступны вне файла, и именно они интересуют программиста - клиента.

	Результатом работы программы является HTML - файл в том же формате, что и остальная документация для Java, так что
	пользователям будет привычно и удобно просматривать и вашу документацию. Попробуй набрать текст предыдущего примера,
	"пропустите" его через javadoc и просмотрите полученный HTML - файл, чтобы увидеть результат.
</p>

<h2>Встроенный HTML</h2>
<p>
	Javadoc вставляет команды HTML в итоговый документ. Это позволяет полностью использовать все возможности HTML;
	впрочем, данная возможность прежде всего ориентирована на форматирование кода:

	<pre>
	//: object/Documentation2.java
	/**
	* <pre>
	* System out println(new Date());
	* </pre>
	*/
	///:~
	</pre>

	Вы можете использовать HTML точно так же, как в обычных страницах, чтобы привести описание к нужному формату:

	<pre>
		//: object/Dcumentation3.java
		/**
		* Можно <em>даже</em> вставить список:
		* <ol>
		* <li> Пункт первый </li>
		* <li> Пункт второй </li>
		* <li> Пункт третий </li>
		* </ol>
		*/
		///:~
	</pre>

	Javadoc игнорирует звёздочки в начале строк, а также начальные пробелы. Текст переформатируется таким образом,
	чтобы он отвечал виду стандартной документации. Не используйте заголовки вида <code><h1></code> или <code><h2></code>
	во встроенном HTML, потому что javadoc вставляет свои собственные заголовки и ваши могут с ними "пересечься".

	Встроенный HTML-код поддерживается всеми типами документации в комментариях - для классов, переменных или методов.
</p>

<h2>Примеры тегов</h2>
<p>
	Далее описаны некоторые их тегов javadoc, используемых при документировании программы. Прежде чем применять javadoc
	для каких-либо серьёзных целей, просмотрите руководство по нему в документации пакета JDK, чтобы получить полную
	информацию о его использовании.

	<h4>@see: ссылка на другие классы</h4>
	Тег позволяет ссылаться на документацию к другим классам. Там, где были записаны теги @see, Javadoc создаёт HTML-
	ссылки на другие документы. Основные формы использования тега:

	<pre>
		@see имя класса
		@see полное-имя-класса
		@see полное-имя-класса#имя-метода
	</pre>

	Каждая из этих форм включает в генерируемую документацию замечание See Also ("см. также") со ссылкой на указанные
	классы. Javadoc не проверяет передаваемые ему гиперссылки.

	<h4>{@link пакет.класс#член_класса метка}</h4>
	Тег очень похож на @see, не считая того, что он может использоваться как встроенный, а вместо стандартного текста
	See Also в ссылке размещается текст, указанный в поле метка.

	<h4>{@docRoot}</h4>
	Позволяет получить относительный пусть к корневой папке, в которой находится документация. Полезен при явном задании
	ссылок на страницы из дерева документации.

	<h4>{@inheritDoc}</h4>
	Наследует документацию базового класса, ближайшего к документируемому классу, в текущий файл с документацией.

	<h4>@version</h4>
	Имеет следующую форму:
	<pre>
		@version информация-о-версии
	</pre>

	Поле информации о версии содержит ту информацию, которую вы сочли нужным включить. Когда в командной строке javadoc
	указывается опция - version, в созданной документации специально отводится место, заполняемое информацией о версиях.

	<h4>@author</h4>
	Записывается в виде
	<pre>
		@author информация-об-авторе
	</pre>


</p>
</body>
</html>